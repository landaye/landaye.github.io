<!DOCTYPE html>
<html lang="zh-cn">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>JavaScript - 兰大爷</title>
  
    <link rel="shortcut icon" href="/../../theme-img/logo.svg">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="JavaScript - 兰大爷" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="https://landaye.github.io/2024/07/30/JavaScript/index.html" />
  
  <meta property="og:image" content="../../images/abstract-8750691_1280.png" />
  
  <meta property="og:article:published_time" content="2024-07-30T07:50:00.000Z" />
  
  <meta property="og:article:author" content="兰大爷" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 7.3.0"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
  <div class="inner">
    <a class="title" href="/">Blog</a>
    <div class="nav-arrow"></div>
    <div class="nav-items">
      <a class="nav-item nav-item-home" href="/"
        >主页</a
      >
       
      <a class="nav-item" href="/archives">全部</a>
        
      <a class="nav-item" href="/categories">分类</a>
        
      <a class="nav-item" href="/friends">朋友</a>
        
      <a class="nav-item" href="/projects">项目</a>
        
      <a class="nav-item" href="/about">关于</a>
        
      <a
        class="nav-item nav-item-github nav-item-icon"
        href="https://github.com/landaye/landaye.github.io.git"
        target="_blank"
        aria-label="GitHub"
        >&nbsp;</a
      >
        
      <a
        class="nav-item nav-item-codepen nav-item-icon"
        href="https://codepen.io/landaye"
        target="_blank"
        aria-label="CodePen"
        >&nbsp;</a
      >
        
      <a
        class="nav-item nav-item-search nav-item-icon"
        href="/search"
        aria-label="Search"
        >&nbsp;</a
      >

       
    </div>
  </div>
</nav>

        
<article class="post">
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/面试/">面试</a>
        
            <a href="/categories/面试/JavaScript/">JavaScript</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>July</span>
            <span>30,</span>
            <span>2024</span>
        </div>
        

        <h1 class="title">JavaScript</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <h1 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h1><hr>
<p>JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（built-in）对象和方法。</p>
<h2 id="说说-JavaScript-中的数据类型？存储上的差别？"><a href="#说说-JavaScript-中的数据类型？存储上的差别？" class="headerlink" title=". 说说 JavaScript 中的数据类型？存储上的差别？"></a>. 说说 JavaScript 中的数据类型？存储上的差别？</h2><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p>
<ol>
<li>基本类型 存储在栈中<ol>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>null</li>
<li>symbol</li>
</ol>
</li>
<li>复杂类型 存储于堆中<ol>
<li>Object</li>
<li>Array</li>
<li>Function</li>
</ol>
</li>
</ol>
<h2 id="深拷贝浅拷贝的区别？如何实现一个深拷贝？"><a href="#深拷贝浅拷贝的区别？如何实现一个深拷贝？" class="headerlink" title=". 深拷贝浅拷贝的区别？如何实现一个深拷贝？"></a>. 深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2><ol>
<li>浅拷贝</li>
</ol>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址（只拷贝栈内存内的）</p>
<p>Object.assign<br>Array.prototype.slice(), Array.prototype.concat()<br>使用拓展运算符实现的复制、</p>
<ol>
<li>深拷贝<br>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</li>
</ol>
<p>_.cloneDeep()<br>jQuery.extend()<br>JSON.stringify()<br>手写循环递归</p>
<h2 id="说说你对闭包的理解？闭包使用场景？"><a href="#说说你对闭包的理解？闭包使用场景？" class="headerlink" title=". 说说你对闭包的理解？闭包使用场景？"></a>. 说说你对闭包的理解？闭包使用场景？</h2><ol>
<li><p>定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。<br>优点是可以避免变量的污染<br>缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
</li>
<li><p>使用场景：<br>创建私有变量<br>延长变量的生命周期</p>
</li>
</ol>
<h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title=". 柯里化函数"></a>. 柯里化函数</h2><p>柯里化是函数式编程中的重要概念，通过将多参数函数转换为一系列单参数函数，使得代码更灵活、更易复用。它可以用于函数复用、延迟计算和函数配置等场景。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">height</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getTenWidthArea</span>(<span class="number">20</span>); <span class="comment">// 200</span></span><br><span class="line"><span class="comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span></span><br><span class="line"><span class="keyword">const</span> getTwentyWidthArea = <span class="title function_">getArea</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> area2 = <span class="title function_">getTwentyWidthArea</span>(<span class="number">15</span>); <span class="comment">// 300</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="说说你对作用域链的理解？"><a href="#说说你对作用域链的理解？" class="headerlink" title=". 说说你对作用域链的理解？"></a>. 说说你对作用域链的理解？</h2><ol>
<li><p>全局作用域<br>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p>
</li>
<li><p>函数作用域<br>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p>
</li>
<li><p>块级作用域<br>ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p>
</li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title=". 变量提升"></a>. 变量提升</h2><p>变量提升是JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。<br>let 和 const 声明的变量也会被提升，但在声明之前访问它们会导致 ReferenceError。<br>函数提升：函数声明会被提升到作用域顶部，而函数表达式不会被提升。</p>
<h2 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title=". JavaScript原型，原型链 ? 有什么特点？"></a>. JavaScript原型，原型链 ? 有什么特点？</h2><ol>
<li><p>原型<br>每个对象都会在其内部初始化一个属性，就是prototype（原型）。<br><strong>proto</strong> 是每个对象（包括实例对象和函数对象）都有的一个属性，它指向该对象的原型。<br>prototype 是函数对象（包括构造函数）的一个属性，它用于创建实例对象的原型。</p>
</li>
<li><p>原型链<br>引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层，组成原型链。原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。</p>
</li>
<li><p>继承存在的意义就是属性共享：好处有二：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性</p>
</li>
</ol>
<h2 id="Javascript如何实现继承？"><a href="#Javascript如何实现继承？" class="headerlink" title=". Javascript如何实现继承？"></a>. Javascript如何实现继承？</h2><ol>
<li>原型链继承</li>
<li>构造函数继承（借助 call）</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>
<h2 id="JavaScript中执行上下文和执行栈是什么？"><a href="#JavaScript中执行上下文和执行栈是什么？" class="headerlink" title=". JavaScript中执行上下文和执行栈是什么？"></a>. JavaScript中执行上下文和执行栈是什么？</h2><p>执行上下文是一种对Javascript代码执行环境的抽象概念. </p>
<p>执行上下文的类型分为三种：</p>
<ol>
<li>全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象</li>
<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</li>
<li>Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用</li>
</ol>
<p>执行栈</p>
<p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文</p>
<h2 id="说说JavaScript中的事件模型"><a href="#说说JavaScript中的事件模型" class="headerlink" title=". 说说JavaScript中的事件模型"></a>. 说说JavaScript中的事件模型</h2><ol>
<li>事件 是用户或浏览器执行的某种动作，可以通过事件监听器进行监听。</li>
<li>事件流 描述事件在页面元素之间的传播方式。<br>事件流三个阶段：<br>  事件捕获阶段(capture phase)<br>  处于目标阶段(target phase)<br>  事件冒泡阶段(bubbling phase)</li>
<li>事件委托 是将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。</li>
<li>事件对象 包含关于事件的详细信息，可在事件处理函数中使用。</li>
</ol>
<p>事件模型</p>
<p>事件模型可以分为三种：</p>
<p>原始事件模型（DOM0级） 不支持事件捕获</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>标准事件模型（DOM2级） 捕获、目标和冒泡</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>IE事件模型（基本不用） 不支持事件捕获</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">attachEvent</span>(‘onclick’, showMessage);</span><br><span class="line">btn.<span class="title function_">detachEvent</span>(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure>
<h2 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title=". typeof 与 instanceof 区别"></a>. typeof 与 instanceof 区别</h2><ol>
<li>typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</li>
<li>instanceof 可判断复杂引用数据类型，不能判断基础数据类型</li>
<li>而typeof 也存在弊端，可以判断基础数据类型（null 除外），引用数据类型中，除了function 类型，其他的也无法判断</li>
</ol>
<p>如果需要通用检测数据类型，可以采用Object.prototype.toString(xxx)，调用该方法，统一返回格式“[object Xxx]”的字符串</p>
<h2 id="解释下什么是事件代理-事件委托-？应用场景？"><a href="#解释下什么是事件代理-事件委托-？应用场景？" class="headerlink" title=". 解释下什么是事件代理(事件委托)？应用场景？"></a>. 解释下什么是事件代理(事件委托)？应用场景？</h2><p>  将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。</p>
<h2 id="说说new操作符具体干了什么？"><a href="#说说new操作符具体干了什么？" class="headerlink" title=". 说说new操作符具体干了什么？"></a>. 说说new操作符具体干了什么？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">Func, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.新对象原型指向构造函数原型对象</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="comment">// 3.将构建函数的this指向新对象</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Func</span>.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">    <span class="comment">// 4.根据构造函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind、call、apply-区别？如何实现一个bind"><a href="#bind、call、apply-区别？如何实现一个bind" class="headerlink" title=". bind、call、apply 区别？如何实现一个bind?"></a>. bind、call、apply 区别？如何实现一个bind?</h2><p>call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</p>
<ol>
<li>三者都可以改变函数的this对象指向</li>
<li>三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window</li>
<li>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入</li>
<li>bind是返回绑定this之后的函数，apply、call 则是立即执行</li>
</ol>
<h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title=". 说说你对事件循环的理解"></a>. 说说你对事件循环的理解</h2><ol>
<li><p>微任务<br>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前<br>常见的微任务有：<br>Promise.then<br>MutaionObserver<br>Object.observe（已废弃；Proxy 对象替代）<br>process.nextTick（Node.js）</p>
</li>
<li><p>宏任务<br>常见的宏任务有：<br>script (可以理解为外层同步代码)<br>setTimeout&#x2F;setInterval<br>UI rendering&#x2F;UI事件<br>postMessage、MessageChannel<br>setImmediate、I&#x2F;O（Node.js）</p>
</li>
<li><p>事件循环的执行顺序</p>
<ol>
<li>执行全局代码（整体代码作为一个宏任务执行）。</li>
<li>遇到异步任务时，将其放入对应的任务队列。</li>
<li>当前宏任务执行完成后，检查并执行所有微任务队列中的任务，直到微任务队列为空。</li>
<li>执行下一个宏任务（从宏任务队列中取出一个任务并执行）。</li>
<li>重复上述过程。</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class="line"><span class="comment">// 遇到定时器，属于新的宏任务，留着后面执行</span></span><br><span class="line"><span class="comment">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class="line"><span class="comment">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class="line"><span class="comment">// 遇到 console.log(3) 直接打印 3</span></span><br><span class="line"><span class="comment">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class="line"><span class="comment">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure>

<h2 id="说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title=". 说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>. 说说你对BOM的理解，常见的BOM对象你了解哪些？</h2><p>BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象<br>其作用就是跟浏览器做一些交互效果.</p>
<ol>
<li>window 对象</li>
<li>location 对象</li>
<li>history 对象</li>
<li>navigator 对象</li>
<li>screen 对象</li>
<li>Document 对象</li>
</ol>
<h2 id="举例说明你对尾递归的理解，有哪些应用场景"><a href="#举例说明你对尾递归的理解，有哪些应用场景" class="headerlink" title=". 举例说明你对尾递归的理解，有哪些应用场景"></a>. 举例说明你对尾递归的理解，有哪些应用场景</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<ol>
<li>数组求和</li>
<li>求斐波那契数列</li>
<li>数组扁平化  数组扁平化是将多维数组转换为一维数组的过程.<ol>
<li>Array.prototype.flat()</li>
<li>Array.prototype.reduce()</li>
</ol>
</li>
<li>数组对象格式化</li>
</ol>
<h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title=". Javascript本地存储的方式有哪些？区别及应用场景？"></a>. Javascript本地存储的方式有哪些？区别及应用场景？</h2><ol>
<li>标记用户与跟踪用户行为的情况，推荐使用cookie</li>
<li>适合长期保存在本地的数据（令牌），推荐使用localStorage</li>
<li>敏感账号一次性登录，推荐使用sessionStorage</li>
<li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</li>
</ol>
<h2 id="说说你对函数式编程的理解？优缺点？"><a href="#说说你对函数式编程的理解？优缺点？" class="headerlink" title=". 说说你对函数式编程的理解？优缺点？"></a>. 说说你对函数式编程的理解？优缺点？</h2><p>函数式编程是一种”编程范式”（programming paradigm）<br>主要的编程范式有三种：命令式编程，声明式编程和函数式编程.</p>
<p>函数式编程更加强调程序执行的结果而非执行的过程.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式编程</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    array[i] = <span class="title class_">Math</span>.<span class="title function_">pow</span>(array[i], <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数式方式</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(num, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"><a href="#Javascript中如何实现函数缓存？函数缓存有哪些应用场景？" class="headerlink" title=". Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"></a>. Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</h2><ol>
<li>闭包</li>
<li>柯里化</li>
<li>高阶函数<br>   用于计算耗时、可能重复利用多次，且是纯函数的<br>纯函数：<br>对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用</li>
</ol>
<h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title=". 什么是防抖和节流？有什么区别？如何实现？"></a>. 什么是防抖和节流？有什么区别？如何实现？</h2><ol>
<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    <div class="about">
        <h1>关于本文</h1>
        <div class="details">
            <p>由 兰大爷 撰写, 采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a> 许可协议.</p>
        </div>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2024/07/30/React/" class="next">
            <div>
                <div class="text">
                    <p class="label">下一篇</p>
                    <h3 class="title">React</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2024/07/30/Algorithm/" class="prev">
            <div>
                <div class="text">
                    <p class="label">上一篇</p>
                    <h3 class="title">Algorithm</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">全部</a>
                
                <a href="/categories" class="item">分类</a>
                
                <a href="/search" class="item">搜索</a>
                
                <a href="/friends" class="item">朋友</a>
                
                <a href="/projects" class="item">项目</a>
                
                <a href="/about" class="item">关于</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a href="https://landaye.github.io/projects/" class="item">Anju</a>
                
                <a href="https://landaye.github.io/projects/" class="item">Axing</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/landaye/landaye.github.io.git" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://codepen.io/landaye" class="item">CodePen</a>
                
                <a href="a2219816262@163.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2024 兰大爷<br>由 <a href="http://hexo.io/" target="_blank">Hexo</a> 驱动 </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>