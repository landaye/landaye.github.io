{"meta":{"title":"兰大爷","subtitle":"兰大爷'S BLOG","description":"悟已往之不谏,知","author":"兰大爷","url":"https://landaye.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-07-30T01:06:49.559Z","updated":"2024-07-30T01:06:49.559Z","comments":true,"path":"categories/index.html","permalink":"https://landaye.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-07-30T04:22:15.000Z","updated":"2024-08-03T08:03:55.986Z","comments":true,"path":"about/index.html","permalink":"https://landaye.github.io/about/index.html","excerpt":"","text":""},{"title":"五湖四海皆是朋友!","date":"2024-07-31T03:44:03.828Z","updated":"2024-07-31T03:44:03.828Z","comments":true,"path":"friends/index.html","permalink":"https://landaye.github.io/friends/index.html","excerpt":"","text":"Contact Me"},{"title":"股市","date":"2023-01-31T16:00:00.000Z","updated":"2024-08-17T05:27:16.228Z","comments":true,"path":"projects/gushi.html","permalink":"https://landaye.github.io/projects/gushi.html","excerpt":"","text":""},{"title":"安居","date":"2023-09-30T16:00:00.000Z","updated":"2024-08-17T05:26:53.585Z","comments":true,"path":"projects/anju.html","permalink":"https://landaye.github.io/projects/anju.html","excerpt":"","text":""},{"title":"阿星商城","date":"2023-10-31T16:00:00.000Z","updated":"2024-08-17T05:27:06.521Z","comments":true,"path":"projects/axing.html","permalink":"https://landaye.github.io/projects/axing.html","excerpt":"","text":""},{"title":"猎犬插件","date":"2023-04-30T16:00:00.000Z","updated":"2024-08-17T05:27:31.920Z","comments":true,"path":"projects/liequan.html","permalink":"https://landaye.github.io/projects/liequan.html","excerpt":"","text":""},{"title":"项目","date":"2024-07-31T11:09:31.199Z","updated":"2024-07-31T11:09:31.199Z","comments":true,"path":"projects/index.html","permalink":"https://landaye.github.io/projects/index.html","excerpt":"","text":""},{"title":"接单小程序","date":"2023-02-28T16:00:00.000Z","updated":"2024-08-17T05:27:24.439Z","comments":true,"path":"projects/jiedan.html","permalink":"https://landaye.github.io/projects/jiedan.html","excerpt":"","text":""},{"title":"search","date":"2024-07-30T04:14:19.000Z","updated":"2024-07-30T04:15:07.512Z","comments":true,"path":"search/index.html","permalink":"https://landaye.github.io/search/index.html","excerpt":"","text":""},{"title":"盲盒小程序","date":"2024-02-29T16:00:00.000Z","updated":"2024-08-17T05:27:40.500Z","comments":true,"path":"projects/manghe.html","permalink":"https://landaye.github.io/projects/manghe.html","excerpt":"","text":""}],"posts":[{"title":"Vue","slug":"Vue","date":"2024-07-31T07:30:00.000Z","updated":"2024-08-18T05:26:07.328Z","comments":true,"path":"2024/07/31/Vue/","permalink":"https://landaye.github.io/2024/07/31/Vue/","excerpt":"","text":"文章内容 . 说说你对 vue 的理解Vue 是一个渐进式的 JavaScript 框架，通过响应式数据绑定、组件化系统、虚拟 DOM、高效的状态管理以及丰富的生态系统，帮助开发者灵活且高效地构建用户界面。 渐进式框架 组件化 响应式系统 虚拟DOM 单文件组件 (SFC) Vue CLI Vue Router 和 Vuex . 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢？ 单页应用（Single Page Application, SPA）是一种Web应用程序，初次加载所需资源加载到浏览器中。通过JavaScript动态更新页面内容。通过发送网络请求和路由来实现数据获取和页面的导航。 优:用户体验好、快，内容的改变不需要重新加载整个页面。代码复用性高。良好的前后端分离，分工更明确。 缺:SEO不友好，不利于搜索引擎的抓取。首次渲染速度相对较慢。 实现SPA:HTML结构：定义页面的基本结构。路由功能：实现一个简单的路由系统，根据URL路径动态加载不同的内容。内容更新：根据当前路由加载相应的内容。事件监听：监听用户的导航行为（例如点击链接）并触发路由更新。 . 如何给SPA做SEO？ SSR服务端渲染将组件或页面通过服务器生成html，再返回给浏览器，如Vue.js–&gt;Nuxt.js React–&gt;Next.js 静态化（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）通过WEB服务器的 URL Rewrite的方式，把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。 使用工具针对爬虫处理，判断是否是搜索引擎，然后动态生成静态HTML页面返回给搜索引擎 . 请描述下你对vue生命周期的理解？ beforeCreate 插件开发中执行一些初始化任务 created 用于异步数据获取 beforeMount 未执行渲染、更新，dom未创建 mounted 用于获取访问数据和dom元素 beforeUpdate 用于获取更新前各种状态 updated 更新后，所有状态已是最新 beforeDestroy 用于一些定时器或订阅的取消 destroyed 组件已销毁，作用同上 . 说说你对keep-alive的理解是什么？缓存后如何获取数据? 设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：首次：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated再次：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated 获取数据：beforeRouteEnteractived注意：服务器端渲染期间avtived不被调用 . 在created和mounted这两个生命周期中请求数据有什么区别呢？created是在组件实例一旦创建完成的时候立刻调用，页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。都能拿到实例对象的属性和方法。放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。 . v-if和v-for的优先级是什么？v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染同一标签进行if判断的时候，v-for是比v-if先进行判断，v-for优先级比v-if高 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断） . Vue组件之间的通信方式都有哪些？vue中8种常规的通信方案 通过 props 传递 父–&gt;子 通过 $emit 触发自定义事件 子–&gt;父子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值父组件绑定监听器获取到子组件传递过来的参数 使用 ref 子–&gt;父 通过获取dom元素传值 EventBus 兄–&gt;兄 $parent 或$root 兄–&gt;兄 通过共同祖辈$parent或者$root搭建通信桥连 attrs 与 listeners 祖–&gt;孙 Provide 与 Inject 祖–&gt;孙在祖先组件定义provide属性，返回传递的值在后代组件通过inject接收组件传递过来的值 Vuex –&gt;复杂关系的组件数据传递Vuex作用相当于一个用来存储共享变量的容器 . VueX state用来存放共享变量的地方 getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值 mutations用来存放修改state的方法。 actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作 . Vue中的$nextTick有什么作用？&#36;nextTick的主要作用是延迟执行某些代码，直到 Vue 完成更新 DOM。用于在数据变化引发的 DOM 更新完成后执行延迟回调。 . 你了解vue的diff算法吗？说说看？ diff 算法是一种通过同层的树节点进行比较的高效算法diff整体策略为：深度优先，同层比较 两个特点：比较只会在同层级进行, 不会跨层级比较在diff比较的过程中，循环从两边向中间比较 render 函数render 函数是 Vue 组件中的一个方法，用于描述组件的视图结构。它返回一个虚拟 DOM 节点树 (VNode)，Vue 根据这个虚拟 DOM 树来更新真实 DOM。 h 函数h 函数（也称为 createElement 函数）是用于创建虚拟 DOM 节点的工具。它是 render 函数的主要构建工具，用于生成虚拟 DOM 树。 patch 函数patch 函数是虚拟 DOM 操作的核心，用于比较新旧虚拟 DOM 树，并将变化应用到真实 DOM 上。它是 Vue 内部的一个重要机制，确保视图更新的高效性。 . Vue项目中有封装过axios吗？主要是封装哪方面的？ 设置接口请求前缀利用node环境变量来作判断，用来区分开发、测试、生产环境在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域 设置请求头与超时时间 封装请求方法先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去 请求拦截器请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便 响应拦截器响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权 . Vue项目中你是如何解决跨域的呢？ JSONP (JSON with Padding)JSONP 是一种通过 &lt;script&gt; 标签实现跨域请求的方法。它只能用于 GET 请求。 CORS (Cross-Origin Resource Sharing)CORS 是一种 W3C 标准，它允许服务器通过 HTTP 头来指示哪些来源站点可以访问该服务器的资源。服务器需要配置相应的响应头： 代理服务器通过设置代理服务器，可以让前端向同源的代理服务器发送请求，再由代理服务器向目标服务器发送请求，代理服务器接收到响应后再返回给前端。 Nginx 反向代理使用 Nginx 配置反向代理，将请求代理到目标服务器。 使用 HTML5 的 iframe 和 postMessage通过在父页面和子页面之间使用 iframe 和 postMessage 来实现跨域通信。 . 为什么data属性是一个函数而不是一个对象？在根实例下data可以是对象也可以是函数，不会产生数据污染情况，但是在组件实例下data必须为函数，为了防止多个组件实例对象之间指向同一个data，产生数据污染。而采用函数的形式，初始化Data时会将其作为工厂函数，每次调用这个函数时，它都会生成并返回一个新的对象实例。 . 动态给vue的data添加一个新的属性时会发生什么？怎样解决？动态地给data添加一个新的属性时，该属性不会自动成为响应式属性 使用 Vue.set 方法 Object.assign()当需要为对象添加多个属性时，可以用 Object.assign(target, obj1, obj2) 合并对象。target 为合并后的对象，obj1 和 obj2 为要合并的对象，当两个对象有相同的 key 时，后面的会覆盖前面的。 $forceUpdate() 重新渲染当前组件 . 双向数据绑定是什么双向数据绑定就是把Model和View绑定，其中一个更新另一个也更新。采用MVVM分层的架构，其中数据与视图关联的核心就是ViewModel，里面通过监听器和解析器来更新数据与视图。 . 说说你对vue的mixin的理解，有什么应用场景？ mixins 是一种复用代码的机制。mixins 将组件中可复用的逻辑提取到一个单独的对象中，然后可以在多个组件中引入和复用这些逻辑。 . slot是什么Web组件内的一个占位符,通过占位符拓展组件，去更好地复用组件和对其做定制化处理。 默认插槽：未命名插槽，用于插入默认内容。 具名插槽：带有名称的插槽，用于在组件中插入不同部分的内容。 作用域插槽：带有作用域的插槽，允许在父组件中访问子组件的属性数据。 . Vue.observable你有了解过吗？说说看Vue.observable 是 一个用于创建响应式对象的全局 API。它允许你创建一个可以被观察的数据对象，这个对象的变化可以被 Vue 的响应式系统自动追踪，从而实现数据的双向绑定和自动更新。 简单的状态管理 非父子组件通信 单文件组件间的状态共享：在单文件组件中，创建一个全局的响应式对象，可以在多个组件中使用这个对象，从而实现状态共享。 参考文献https://vue3js.cn/interview/","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"ES6","slug":"ES6","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:10:53.835Z","comments":true,"path":"2024/07/30/ES6/","permalink":"https://landaye.github.io/2024/07/30/ES6/","excerpt":"","text":"文章内容 . 你是怎么理解 ES6 中 Promise 的？使用场景？Promise 是异步编程的一种解决方案,有三种状态 pending（进行中） fulfilled（已成功） rejected（已失败）Promise 对象是一个构造函数，生成 Promise 实例,实例存在以下方法： then() catch() finally() 当下个异步请求依赖上个请求结果时，Promise 的链式操作就很友好。 . 异步解决方案 回调函数 Promise 对象 generator 函数 async&#x2F;await . Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？为了解决 defineProperty API 检测不到对象属性的添加和删除 数组 API 方法无法监听到 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题 . 对象新增了哪些扩展？ 属性的简写 键名与对应值名相等可以简写 属性名表达式 super 关键字 扩展运算符的应用 对象新增的方法Object.is()Object.assign()Object.getOwnPropertyDescriptors()Object.setPrototypeOf()，Object.getPrototypeOf()Object.keys()，Object.values()，Object.entries()Object.fromEntries()#Object.is()","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"Css","slug":"Css","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:03:24.382Z","comments":true,"path":"2024/07/30/Css/","permalink":"https://landaye.github.io/2024/07/30/Css/","excerpt":"","text":"文章内容 . 怎么理解回流跟重绘？什么场景下会触发？ 回流：布局引擎根据各种样式计算每个盒子在页面上的大小与位置 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制 . 什么是重排（回流）什么是重绘？ 重排（Reflow）浏览器重新渲染部分或全部文档而重新计算元素的位置和几何结构的过程。例如改变了元素的宽度、高度、边距、位置等 重绘（Repaint）浏览器更新页面上元素的样式的过程，不涉及元素的几何位置变化。当元素的样式发生变化，浏览器会重新绘制元素的外观。 . 说说你对盒子模型的理解?浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）一个盒子由四个部分组成：content、padding、border、margin。 标准盒子模型：width 和 height 属性只包括内容区域（content），不包括内边距、边框和外边距。计算公式：元素总宽度 &#x3D; content width + padding + border + margin IE 怪异盒子模型：width 和 height 属性包括内容区域、内边距和边框，但不包括外边距。计算公式：元素总宽度 &#x3D; width + margin（width 已经包含了内容、内边距和边框） . css 选择器有哪些？优先级？哪些属性可以继承？ css 属性选择器常用的有：id 选择器（#box），选择 id 为 box 的元素类选择器（.one），选择类名为 one 的所有元素标签选择器（div），选择标签为 div 的所有元素后代选择器（#box div），选择 id 为 box 元素内部所有的 div 元素子选择器（.one&gt;one_1），选择父元素为.one 的所有.one_1 的元素相邻同胞选择器（.one+.two），选择紧接在.one 之后的所有.two 元素群组选择器（div,p），选择 div、p 的所有元素 内联 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 . css 中，有哪些方式可以隐藏页面元素？区别? display:none visibility:hidden opacity:0 设置 height、width 模型属性为 0 position:absolute clip-path . 常见的块级元素，内联元素有哪些？ 块级元素（Block Elements）块级元素通常会占据其父容器的整个宽度，并且总是从新的一行开始。div，p，h1，h6，ul，ol，li，section，article，header，footer，nav 内联元素（Inline Elements）内联元素只占据它们所包含内容的宽度，不会独占一行。span，a，img，strong，em，b，i，u，br，code . 如何实现 div 同一行显示？ 使用 display: inline-block 使用浮动（Float） 使用 Flexbox 使用 CSS Grid 使用 transform 和 translateX 使用 position: absolute . 介绍一下 grid 网格布局和 Flexbox 弹性盒子布局 Grid 布局Grid 布局是一种基于网格的二维布局系统，可以同时处理行和列。它特别适合复杂的布局，允许我们精确控制各个元素在网格中的位置。 grid-template-columns: 定义列的宽度。 grid-template-rows: 定义行的高度。 grid-template-areas 用于定义 Grid 区域的布局，通过名称指定每个单元格所在的区域。 grid-column-gap: 设置列间距。 grid-row-gap: 设置行间距。 grid-gap: 同时设置列和行的间距。 grid-auto-columns: 定义自动生成的列的宽度。 grid-auto-rows: 定义自动生成的行的高度。 grid-auto-flow 控制自动放置的 Grid 项目的排列方式： justify-items: 设置项目在主轴（水平）上的对齐。 align-items: 设置项目在交叉轴（垂直）上的对齐。 justify-content: 设置容器内网格区域在主轴（水平）上的对齐。 align-content: 设置容器内网格区域在交叉轴（垂直）上的对齐。 Flexbox 布局Flexbox 布局是一种基于弹性盒子的布局模型，适用于一维布局，可以在行或列方向上对元素进行排列和对齐。它特别适合那些需要灵活、响应式布局的场景。容器属性有： flex-direction 主轴的方向 flex-wrap 沿主轴排列，是否可换行 flex-flow flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap justify-content 主轴上的对齐方式 align-items 交叉轴上对齐 align-content 多根轴线的对齐方式 . 如何实现单行／多行文本溢出的省略样式？ 单行文本溢出省略 overflow:hidden 隐藏溢出元素 white-space:nowrap 文本不换行 text-overflow 属性：clip：当对象内文本溢出部分裁切掉ellipsis：当对象内文本溢出时显示省略标记（…） 多行文本溢出省略 基于高度截断 #伪元素 + 定位 12345678910111213.demo &#123; position: relative; line-height: 20px; height: 40px; overflow: hidden;&#125;.demo::after &#123; content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding: 0 20px 0 10px;&#125; 基于行数截断 123456789p &#123; width: 400px; border-radius: 1px solid red; -webkit-line-clamp: 2; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis;&#125; . CSS 如何画一个三角形？原理是什么？利用边框的特性。通过设置元素的宽度和高度为零，并且为不同边设置不同颜色的边框，可以创建各种方向的三角形。 1234567.border &#123; width: 0; height: 0; border-style: solid; border-width: 0 50px 50px; border-color: transparent transparent #d9534f;&#125; 空心三角形 1234567891011121314151617.border &#123; width: 0; height: 0; border-style: solid; border-width: 0 50px 50px; border-color: transparent transparent #d9534f; position: relative;&#125;.border:after &#123; content: &quot;&quot;; border-style: solid; border-width: 0 40px 40px; border-color: transparent transparent #96ceb4; position: absolute; top: 6px; left: -40px;&#125; . 让 Chrome 支持小于 12px 的文字方式有哪些？区别？ zoomzoom:50%，表示缩小到原来的一半zoom:0.5，表示缩小到原来的一半 -webkit-transform:scale() -webkit-text-size-adjust:none 谷歌浏览器有版本要求 . 说说对 Css 预编语言的理解？有哪些区别?CSS 预编译语言通过添加变量、嵌套规则、混入（mixins）、函数和继承等功能，简化了 CSS 的编写和管理。经过编译器转换成标准的 CSS 代码，然后渲染。 sass less stylus 主要区别 语法不同：Stylus 支持无括号和无分号的极简语法。 变量表示不同：Sass 使用 $ 符号定义变量。LESS 使用 @ 符号定义变量。Stylus 直接定义变量。 函数和混入：Sass 和 Stylus 支持复杂的函数和混入。LESS 的混入相对简单，但也提供基本功能。 . 什么是响应式设计？响应式设计的基本原理是什么？如何做？响应式设计是一种网页设计理念，通过动态调整布局和内容来适应不同的屏幕尺寸和设备特性。 流式布局：使用相对单位来定义布局的宽度和元素的尺寸，而不是固定的像素值。 媒体查询：使用 CSS 媒体查询来应用不同的样式规则，针对不同的设备特性进行调整。 弹性网格：使用弹性网格系统来创建布局，这种布局根据设备的屏幕尺寸自动调整。 选择断点，针对不同断点实现不同布局和内容展示。 . 元素水平垂直居中的方法有哪些？如果元素不定宽高是否可以呢？利用定位+margin:auto 可以利用定位+margin:负值利用定位+transform 可以table 布局flex 布局 可以grid 布局 可以 . 谈谈你对 BFC 的理解？一个块级格式化上下文(作用域)，它在布局过程中形成一个独立的区域，用于控制块级元素的排版和浮动行为。内部子元素不会影响外部元素BFC 的作用：防止元素重叠：BFC 可以解决浮动元素之间的重叠问题。处理外边距折叠：(margin 重叠)两个相邻块级元素之间的垂直外边距合并成一个外边距的现象清除浮动: 子元素是浮动的，父元素的高度可能会被压缩 . 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？两栏布局，右侧自适应：可以使用 Flexbox、Grid 或传统的浮动布局实现。 123456789101112131415161718192021222324252627282930313233343536/* 启用 Flexbox 布局 */.container &#123; display: flex; /* 启用 Flexbox 布局 */&#125;.left &#123; width: 200px; /* 左侧固定宽度 */ background: lightcoral;&#125;.right &#123; flex: 1; /* 右侧自适应剩余空间 */ background: lightblue;&#125;/* 启用 grid 布局 */.container &#123; display: grid; grid-template-columns: 200px 1fr; /* 左侧固定宽度，右侧自适应 */&#125;.left &#123; background: lightcoral;&#125;.right &#123; background: lightblue;&#125;/* 启用 浮动 布局 */.container &#123; overflow: hidden; /* 清除浮动 */&#125;.left &#123; float: left; width: 200px; /* 左侧固定宽度 */ background: lightcoral;&#125;.right &#123; margin-left: 200px; /* 右侧从左侧宽度起始 */ background: lightblue;&#125; 三栏布局，中间自适应：可以使用 Flexbox、Grid 或传统的浮动布局实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 启用 Flexbox 布局 */.container &#123; display: flex; /* 启用 Flexbox 布局 */&#125;.left,.right &#123; width: 150px; /* 左右两侧固定宽度 */&#125;.center &#123; flex: 1; /* 中间栏自适应剩余空间 */ background: lightblue;&#125;.left &#123; background: lightcoral;&#125;.right &#123; background: lightgreen;&#125;/* 启用 grid 布局 */.container &#123; display: grid; grid-template-columns: 150px 1fr 150px; /* 左右固定宽度，中间自适应 */&#125;.left &#123; background: lightcoral;&#125;.center &#123; background: lightblue;&#125;.right &#123; background: lightgreen;&#125;/* 启用 浮动 布局 */.container &#123; overflow: hidden; /* 清除浮动 */&#125;.left,.right &#123; float: left; width: 150px; /* 左右两侧固定宽度 */&#125;.center &#123; margin-left: 150px; /* 从左侧栏宽度开始 */ margin-right: 150px; /* 到右侧栏宽度结束 */ background: lightblue;&#125;.left &#123; background: lightcoral;&#125;.right &#123; float: right; /* 右侧栏浮动到右边 */ background: lightgreen;&#125;","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"Http","slug":"Http","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:09:42.971Z","comments":true,"path":"2024/07/30/Http/","permalink":"https://landaye.github.io/2024/07/30/Http/","excerpt":"","text":"文章内容 . 如何理解 OSI 七层模型? 物理层（Physical Layer）作用: 负责传输原始的比特流（0 和 1），并定义了网络设备之间的电气和机械接口。这一层处理的是硬件设备如网卡、电缆、交换机的实际信号传输。 例子: 电缆类型（光纤、双绞线）、网络接口卡（NIC）等。 数据链路层（Data Link Layer）作用: 负责在物理层之上建立、维护和释放数据链路。它提供错误检测和纠正功能，确保数据在物理链路上传输的可靠性。此层将数据帧传送给物理层，并处理 MAC（媒体访问控制）地址。 例子: 以太网、Wi-Fi、PPP（点对点协议）。 网络层（Network Layer）作用: 负责数据包的路由和转发。它处理逻辑地址（如 IP 地址），并将数据包从源主机传输到目标主机，通常涉及不同网络的通信。 例子: IP 协议、ICMP（互联网控制消息协议）。 传输层（Transport Layer）作用: 负责数据的端到端传输和完整性，提供错误检测和修正。它将数据从应用层传递到网络层，并确保数据的顺序和完整性。 例子: TCP（传输控制协议）、UDP（用户数据报协议）。 会话层（Session Layer）作用: 负责建立、管理和终止应用程序之间的会话。它提供会话恢复功能，并管理会话之间的数据交换。 例子: NetBIOS、RPC（远程过程调用）。 表示层（Presentation Layer）作用: 负责数据的表示和编码，确保应用层能够理解和处理数据。这一层处理数据的转换、加密和解密。 例子: 数据格式转换（如 ASCII 到 EBCDIC）、加密协议（如 SSL&#x2F;TLS）。 应用层（Application Layer）作用: 提供网络服务给用户的应用程序，是 OSI 模型的最上层。它直接与应用程序交互，处理各种网络应用和服务，如电子邮件、文件传输和网页浏览。 例子: HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）。","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"Electron","slug":"Electron","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:06:28.967Z","comments":true,"path":"2024/07/30/Electron/","permalink":"https://landaye.github.io/2024/07/30/Electron/","excerpt":"","text":"文章内容 . vue3+electron搭建项目 vue3+electron","categories":[{"name":"前端","slug":"前端","permalink":"https://landaye.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Node","slug":"Node","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:15:02.632Z","comments":true,"path":"2024/07/30/Node/","permalink":"https://landaye.github.io/2024/07/30/Node/","excerpt":"","text":"文章内容 . 使用nvm搭建多版本node nvm搭建node","categories":[{"name":"前端","slug":"前端","permalink":"https://landaye.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"React","slug":"React","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T05:27:22.922Z","comments":true,"path":"2024/07/30/React/","permalink":"https://landaye.github.io/2024/07/30/React/","excerpt":"","text":"文章内容 . 说说对 React 的理解？有哪些特性？ 用于构建用户界面的 JavaScript 库,虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的单向数据流. 特性 JSX 语法 单向数据绑定 虚拟 DOM 声明式编程 Component . 说说 Real DOM 和 Virtual DOM 的区别？优缺点？ Virtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述 区别:虚拟 DOM 不会进行排版与重绘操作,而真实 DOM 会频繁重排与重绘 . 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？ 挂载阶段（Mounting）： constructor(props)：组件的构造函数，用于初始化 state 和绑定事件处理方法。 static getDerivedStateFromProps(props, state)：用于根据新的 props 更新 state。 render()：返回要渲染的 React 元素，是必须实现的方法。 componentDidMount()：在组件挂载后立即调用，适合进行网络请求、订阅事件等初始化操作。 更新阶段（Updating）： static getDerivedStateFromProps(props, state)：在此阶段也会被调用。 shouldComponentUpdate(nextProps, nextState)：用于控制组件是否重新渲染。 render()：重新渲染组件。 getSnapshotBeforeUpdate(prevProps, prevState)：在最近一次渲染输出（提交到 DOM 节点）之前调用。 componentDidUpdate(prevProps, prevState, snapshot)：在更新后立即调用。 卸载阶段（Unmounting）： componentWillUnmount()：在组件卸载前调用，用于清理资源，如取消网络请求、移除监听器等。 错误处理阶段，包括 componentDidCatch(error, info) 方法，用于捕获子组件树中的错误。 . React 怎么优化渲染性能？ 使用 React.memo对于函数组件，使用 React.memo 可以防止在 props 没有变化时重新渲染组件。React.memo 会对 props 进行浅比较，如果没有变化就不会触发重新渲染。 123const MyComponent = React.memo((props) =&gt; &#123; return &lt;div&gt;&#123;props.value&#125;&lt;/div&gt;;&#125;); 使用 shouldComponentUpdate 或 PureComponent在类组件中，shouldComponentUpdate 方法可以用于手动控制组件是否需要更新。PureComponent 通过浅比较 props 和 state 自动实现了这一功能。 12345class MyComponent extends React.PureComponent &#123; render() &#123; return &lt;div&gt;&#123;this.props.value&#125;&lt;/div&gt;; &#125;&#125; 优化渲染列表循环渲染使用 key 属性来帮助 React 识别哪些项被改变、添加或者删除，避免不必要的渲染。 123const listItems = this.state.items.map((item, index) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;)); 使用懒加载组件使用 React.lazy 和 Suspense 来懒加载组件，可以减少初始加载时间。 1234567891011const OtherComponent = React.lazy(() =&gt; import(&quot;./OtherComponent&quot;));function MyComponent() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );&#125; 减少渲染层级尽量减少组件树的层级，扁平化的组件结构可以减少渲染时间。 使用 useMemo 和 useCallbackuseMemo：用于缓存复杂计算的结果，避免在每次渲染时都重新计算。 1const computedValue = useMemo(() =&gt; expensiveComputation(a, b), [a, b]); useCallback：用于缓存回调函数，避免函数在每次渲染时都重新创建。 123const memoizedCallback = useCallback(() =&gt; &#123; doSomething();&#125;, [dependencies]); . React 使用过哪些命令式方式使用组件？ 使用 Refs 访问 DOM 元素Refs 允许你直接访问 DOM 元素或组件实例，可以在需要直接操作 DOM 的情况下使用。 使用 forceUpdate 方法:强制组件重新渲染 通过 forwardRef 和 useImperativeHandle 来实现自定义暴露给父组件的命令 1234567891011121314151617181920212223242526import React, &#123; useRef, forwardRef, useImperativeHandle &#125; from &quot;react&quot;;const ChildComponent = forwardRef((props, ref) =&gt; &#123; useImperativeHandle(ref, () =&gt; (&#123; alertMessage() &#123; alert(&quot;Message from Child Component!&quot;); &#125;, &#125;)); return &lt;div&gt;Child Component&lt;/div&gt;;&#125;);function ParentComponent() &#123; const childRef = useRef(null); const triggerAlert = () =&gt; &#123; childRef.current.alertMessage(); // 命令式地触发子组件方法 &#125;; return ( &lt;div&gt; &lt;ChildComponent ref=&#123;childRef&#125; /&gt; &lt;button onClick=&#123;triggerAlert&#125;&gt;Trigger Alert&lt;/button&gt; &lt;/div&gt; );&#125; . react 缓存怎么实现 使用 React 内部状态进行缓存在组件内部使用 useState 或 useReducer 进行简单的数据缓存。比如，当你从 API 获取数据后，可以将数据存储在组件的状态中，之后再次渲染时，如果数据已经存在，就不再重新请求。 123456789101112131415161718192021import React, &#123; useState, useEffect &#125; from &quot;react&quot;;function DataComponent() &#123; const [data, setData] = useState(null); useEffect(() =&gt; &#123; if (!data) &#123; // 检查数据是否已经存在 fetchData().then((fetchedData) =&gt; setData(fetchedData)); &#125; &#125;, [data]); const fetchData = async () =&gt; &#123; // 模拟 API 请求 const response = await fetch(&quot;https://api.example.com/data&quot;); const result = await response.json(); return result; &#125;; return &lt;div&gt;&#123;data ? &lt;DisplayData data=&#123;data&#125; /&gt; : &lt;Loading /&gt;&#125;&lt;/div&gt;;&#125; 使用 useMemo 和 useCallback 缓存计算结果和函数useMemo 和 useCallback 可以用来缓存函数的计算结果或缓存一个回调函数，这样可以避免不必要的重新计算或函数重新创建。 1234567891011121314151617181920212223import React, &#123; useState, useMemo &#125; from &quot;react&quot;;function ExpensiveCalculationComponent(&#123; num &#125;) &#123; const [count, setCount] = useState(0); // 通过 useMemo 缓存昂贵的计算结果 const expensiveValue = useMemo(() =&gt; &#123; return expensiveCalculation(num); &#125;, [num]); function expensiveCalculation(num) &#123; // 模拟一个昂贵的计算 console.log(&quot;Calculating...&quot;); return num * 2; &#125; return ( &lt;div&gt; &lt;p&gt;Expensive Value: &#123;expensiveValue&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment: &#123;count&#125;&lt;/button&gt; &lt;/div&gt; );&#125; 使用 LocalStorage 或 SessionStorage 进行持久化缓存可以将数据缓存到 localStorage 或 sessionStorage 中，这样即使用户刷新页面，数据依然存在。 . react 组件间通信方式 Props（属性）父组件到子组件：父组件可以通过 props 将数据传递给子组件。 1234567function ParentComponent() &#123; return &lt;ChildComponent message=&quot;Hello from Parent&quot; /&gt;;&#125;function ChildComponent(&#123; message &#125;) &#123; return &lt;div&gt;&#123;message&#125;&lt;/div&gt;;&#125; 子组件到父组件：子组件可以通过调用 props 中的回调函数将数据传递给父组件。 123456789101112131415function ParentComponent() &#123; const handleChildClick = (childData) =&gt; &#123; // 处理子组件传递的数据 &#125;; return &lt;ChildComponent onChildClick=&#123;handleChildClick&#125; /&gt;;&#125;function ChildComponent(&#123; onChildClick &#125;) &#123; const handleClick = () =&gt; &#123; onChildClick(&quot;Data from Child&quot;); &#125;; return &lt;button onClick=&#123;handleClick&#125;&gt;Click me&lt;/button&gt;;&#125; Context APIContext 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 123456789101112131415//创建 Context：const MyContext = React.createContext(defaultValue);//父组件提供数据：function ParentComponent() &#123; return ( &lt;MyContext.Provider value=&quot;Hello from Parent&quot;&gt; &lt;ChildComponent /&gt; &lt;/MyContext.Provider&gt; );&#125;//子组件消费数据：function ChildComponent() &#123; const context = useContext(MyContext); return &lt;div&gt;&#123;context&#125;&lt;/div&gt;;&#125; Refs使用 ref 可以获取组件实例，从而调用实例的方法或访问其属性。 123456789101112131415161718192021222324function ParentComponent() &#123; const childRef = useRef(); const focusChild = () =&gt; &#123; childRef.current.focus(); &#125;; return ( &lt;&gt; &lt;ChildComponent ref=&#123;childRef&#125; /&gt; &lt;button onClick=&#123;focusChild&#125;&gt;Focus Child&lt;/button&gt; &lt;/&gt; );&#125;class ChildComponent extends React.Component &#123; focus = () =&gt; &#123; // ... &#125;; render() &#123; return &lt;input /&gt;; &#125;&#125; Events（事件）通过在父组件中定义事件处理函数，并在子组件中触发该事件。 12345678910111213141516171819function ParentComponent() &#123; const handleCustomEvent = (eventData) =&gt; &#123; // 处理事件 &#125;; return ( &lt;div&gt; &lt;ChildComponent onCustomEvent=&#123;handleCustomEvent&#125; /&gt; &lt;/div&gt; );&#125;function ChildComponent(&#123; onCustomEvent &#125;) &#123; const triggerEvent = () =&gt; &#123; onCustomEvent(&quot;data from child&quot;); &#125;; return &lt;button onClick=&#123;triggerEvent&#125;&gt;Trigger Event&lt;/button&gt;;&#125; ReduxRedux 是一个独立于 React 的状态管理库，但它经常与 React 一起使用。 Action： 一个描述发生了什么的对象。 Reducer： 根据旧的 state 和 action 返回新的 state 的函数。 Store： 整个应用的状态中心。 useReducer 和 useContextuseReducer 和 useContext 可以一起使用，以实现类似 Redux 的状态管理，而不需要引入额外的库。 1234567891011121314151617181920const MyContext = React.createContext();function reducer(state, action) &#123; // 根据action处理state&#125;function ParentComponent() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;MyContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt; &lt;ChildComponent /&gt; &lt;/MyContext.Provider&gt; );&#125;function ChildComponent() &#123; const &#123; state, dispatch &#125; = useContext(MyContext); // 使用 state 和 dispatch&#125; 参考文献https://vue3js.cn/interview/","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"场景","slug":"changjing","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:16:44.762Z","comments":true,"path":"2024/07/30/changjing/","permalink":"https://landaye.github.io/2024/07/30/changjing/","excerpt":"","text":"文章内容 . 如果一个元素频繁改变大小从而频繁触发重排怎么解决？ 使用 CSS3 的 transform 属性将元素的尺寸变化通过 transform: scale();来实现，而不是直接修改 width 和 height。transform 不会触发重排，而是触发重绘。 12345.element &#123; transform: scale(1); /* 初始状态 */&#125;// 使用JavaScript修改scale值element.style.transform = &#x27;scale(&#x27; + newSize / originalSize + &#x27;)&#x27;; 离线操作 DOM将元素从文档流中移除，进行修改后再放回原位置。 12345678const parent = element.parentNode;const nextElement = element.nextSibling;parent.removeChild(element);// 进行修改element.style.width = &quot;100px&quot;;element.style.height = &quot;100px&quot;;// 重新插入DOMparent.insertBefore(element, nextElement); 使用 requestAnimationFrame将多次尺寸变化合并到一次 requestAnimationFrame 回调中，减少重排次数。 1234567function updateElementSize() &#123; // 需要改变大小的操作 element.style.width = newWidth + &quot;px&quot;; element.style.height = newHeight + &quot;px&quot;;&#125;requestAnimationFrame(updateElementSize); 批量修改 DOM如果需要多次修改 DOM，可以使用 DocumentFragment 或创建一个临时的元素，在内存中完成所有操作后再一次性更新到 DOM。 1234const fragment = document.createDocumentFragment();// 在fragment上进行所有DOM操作// ...parent.appendChild(fragment); 优化 CSS 选择器简化 CSS 选择器，避免使用深层次或复杂的选择器，减少重排时的计算量。 使用绝对定位将元素设置为绝对定位，这样它的变化不会影响到其他元素，从而减少重排的范围。 123.element &#123; position: absolute;&#125; 缓存布局信息如果需要频繁访问元素的布局信息（如 offsetWidth），可以将其缓存起来，避免多次查询导致重排。 12const cachedWidth = element.offsetWidth;// 使用cachedWidth进行后续操作 限制重排范围通过限制元素的大小变化范围，减少不必要的重排。 硬件加速通过 CSS 的 transform: translateZ(0);开启硬件加速，让 GPU 处理动画效果，减少 CPU 的压力。 123.element &#123; transform: translateZ(0);&#125; . 什么是重排（回流）什么是重绘？ 重排（Reflow）浏览器重新渲染部分或全部文档而重新计算元素的位置和几何结构的过程。例如改变了元素的宽度、高度、边距、位置等 重绘（Repaint）浏览器更新页面上元素的样式的过程，不涉及元素的几何位置变化。当元素的样式发生变化，浏览器会重新绘制元素的外观。 . 怎么把一个元素从页面的左上角移动到页面的右下角？ 利用 CSS 的 transform 属性，可以在不更改 top 和 left 的情况下移动元素。 通过改变 CSS Grid 或 Flexbox 布局的位置属性来移动元素。 通过 CSS 的 @keyframes 定义动画，从左上角移动到右下角。","categories":[{"name":"前端","slug":"前端","permalink":"https://landaye.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"ReactNative","slug":"ReactNative","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-18T04:12:24.139Z","comments":true,"path":"2024/07/30/ReactNative/","permalink":"https://landaye.github.io/2024/07/30/ReactNative/","excerpt":"","text":"文章内容 . React Native环境配置搭建 React Native","categories":[{"name":"前端","slug":"前端","permalink":"https://landaye.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2024-07-30T07:50:00.000Z","updated":"2024-08-18T04:36:30.432Z","comments":true,"path":"2024/07/30/JavaScript/","permalink":"https://landaye.github.io/2024/07/30/JavaScript/","excerpt":"","text":"文章内容 JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（built-in）对象和方法。 . 说说 JavaScript 中的数据类型？存储上的差别？在JavaScript中，我们可以分成两种类型： 基本类型 存储在栈中 String Boolean Undefined null symbol 复杂类型 存储于堆中 Object Array Function . 深拷贝浅拷贝的区别？如何实现一个深拷贝？ 浅拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址（只拷贝栈内存内的） Object.assignArray.prototype.slice(), Array.prototype.concat()使用拓展运算符实现的复制、 深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 _.cloneDeep()jQuery.extend()JSON.stringify()手写循环递归 . 说说你对闭包的理解？闭包使用场景？ 定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。优点是可以避免变量的污染缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 使用场景：创建私有变量延长变量的生命周期 . 柯里化函数柯里化是函数式编程中的重要概念，通过将多参数函数转换为一系列单参数函数，使得代码更灵活、更易复用。它可以用于函数复用、延迟计算和函数配置等场景。 123456789101112function getArea(width) &#123; return height =&gt; &#123; return width * height; &#125;&#125;const getTenWidthArea = getArea(10);// 之后碰到宽度为10的长方形就可以这样计算面积const area1 = getTenWidthArea(20); // 200// 而且如果遇到宽度偶尔变化也可以轻松复用const getTwentyWidthArea = getArea(20);const area2 = getTwentyWidthArea(15); // 300 . 说说你对作用域链的理解？在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域 全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问 函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问 块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量 . 变量提升变量提升是JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。let 和 const 声明的变量也会被提升，但在声明之前访问它们会导致 ReferenceError。函数提升：函数声明会被提升到作用域顶部，而函数表达式不会被提升。 . JavaScript原型，原型链 ? 有什么特点？ 原型每个对象都会在其内部初始化一个属性，就是prototype（原型）。proto 是每个对象（包括实例对象和函数对象）都有的一个属性，它指向该对象的原型。prototype 是函数对象（包括构造函数）的一个属性，它用于创建实例对象的原型。 原型链引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层，组成原型链。原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。 继承存在的意义就是属性共享：好处有二：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性 . Javascript如何实现继承？ 原型链继承 构造函数继承（借助 call） 组合继承 原型式继承 寄生式继承 寄生组合式继承 . JavaScript中执行上下文和执行栈是什么？执行上下文是一种对Javascript代码执行环境的抽象概念. 执行上下文的类型分为三种： 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用 执行栈 执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文 . 说说JavaScript中的事件模型 事件 是用户或浏览器执行的某种动作，可以通过事件监听器进行监听。 事件流 描述事件在页面元素之间的传播方式。事件流三个阶段： 事件捕获阶段(capture phase) 处于目标阶段(target phase) 事件冒泡阶段(bubbling phase) 事件委托 是将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。 事件对象 包含关于事件的详细信息，可在事件处理函数中使用。 事件模型 事件模型可以分为三种： 原始事件模型（DOM0级） 不支持事件捕获 123var btn = document.getElementById(&#x27;.btn&#x27;);btn.onclick = fun; 标准事件模型（DOM2级） 捕获、目标和冒泡 123var btn = document.getElementById(&#x27;.btn&#x27;);btn.addEventListener(‘click’, showMessage, false);btn.removeEventListener(‘click’, showMessage, false); IE事件模型（基本不用） 不支持事件捕获 123var btn = document.getElementById(&#x27;.btn&#x27;);btn.attachEvent(‘onclick’, showMessage);btn.detachEvent(‘onclick’, showMessage); . typeof 与 instanceof 区别 typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值 instanceof 可判断复杂引用数据类型，不能判断基础数据类型 而typeof 也存在弊端，可以判断基础数据类型（null 除外），引用数据类型中，除了function 类型，其他的也无法判断 如果需要通用检测数据类型，可以采用Object.prototype.toString(xxx)，调用该方法，统一返回格式“[object Xxx]”的字符串 . 解释下什么是事件代理(事件委托)？应用场景？ 将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。 . 说说new操作符具体干了什么？12345678910function mynew(Func, ...args) &#123; // 1.创建一个新对象 const obj = &#123;&#125; // 2.新对象原型指向构造函数原型对象 obj.__proto__ = Func.prototype // 3.将构建函数的this指向新对象 let result = Func.apply(obj, args) // 4.根据构造函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理 return result instanceof Object ? result : obj&#125; . bind、call、apply 区别？如何实现一个bind?call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向 三者都可以改变函数的this对象指向 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入 bind是返回绑定this之后的函数，apply、call 则是立即执行 . 说说你对事件循环的理解 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前常见的微任务有：Promise.thenMutaionObserverObject.observe（已废弃；Proxy 对象替代）process.nextTick（Node.js） 宏任务常见的宏任务有：script (可以理解为外层同步代码)setTimeout&#x2F;setIntervalUI rendering&#x2F;UI事件postMessage、MessageChannelsetImmediate、I&#x2F;O（Node.js） 事件循环的执行顺序 执行全局代码（整体代码作为一个宏任务执行）。 遇到异步任务时，将其放入对应的任务队列。 当前宏任务执行完成后，检查并执行所有微任务队列中的任务，直到微任务队列为空。 执行下一个宏任务（从宏任务队列中取出一个任务并执行）。 重复上述过程。 12345678910111213141516171819console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3)// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 . 说说你对BOM的理解，常见的BOM对象你了解哪些？BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象其作用就是跟浏览器做一些交互效果. window 对象 location 对象 history 对象 navigator 对象 screen 对象 Document 对象 . 举例说明你对尾递归的理解，有哪些应用场景123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 数组求和 求斐波那契数列 数组扁平化 数组扁平化是将多维数组转换为一维数组的过程. Array.prototype.flat() Array.prototype.reduce() 数组对象格式化 . Javascript本地存储的方式有哪些？区别及应用场景？ 标记用户与跟踪用户行为的情况，推荐使用cookie 4kb 适合长期保存在本地的数据（令牌），推荐使用localStorage 5m 敏感账号一次性登录，推荐使用sessionStorage 5m 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB . 说说你对函数式编程的理解？优缺点？函数式编程是一种”编程范式”（programming paradigm）主要的编程范式有三种：命令式编程，声明式编程和函数式编程. 函数式编程更加强调程序执行的结果而非执行的过程. 1234567// 命令式编程var array = [0, 1, 2, 3]for(let i = 0; i &lt; array.length; i++) &#123; array[i] = Math.pow(array[i], 2)&#125;// 函数式方式[0, 1, 2, 3].map(num =&gt; Math.pow(num, 2)) . Javascript中如何实现函数缓存？函数缓存有哪些应用场景？ 闭包 柯里化 高阶函数 用于计算耗时、可能重复利用多次，且是纯函数的纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用 . 什么是防抖和节流？有什么区别？如何实现？ 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 1234567891011function throttled2(fn, delay = 500) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) timer = null &#125;, delay); &#125; &#125;&#125; 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 12345678910111213function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; // 保存this指向 let args = arguments; // 拿到event对象 clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; . 谈谈 JavaScript 中的类型转换机制 强制转换（显示转换）Number()parseInt()String()Boolean() 自动转换（隐式转换） 比较运算（&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;）、if、while需要布尔值地方 算术运算（+、-、*、&#x2F;、%） . 说说 JavaScript 中内存泄漏的几种情况？不再需要的内存没有被及时释放 全局变量泄漏 闭包中的内存泄漏 遗留的 DOM 引用 未清理的定时器和回调 事件监听器泄漏 . 说说 Javascript 数字精度丢失的问题，如何解决？ 使用整数运算 使用 Math.round() 使用库 . 如何判断一个元素是否在可视区域中？ offsetTop、scrollTop getBoundingClientRect Intersection Observer . 大文件上传如何做断点续传？ 分片上传分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块来进行分片上传 断点续传断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分每一个部分采用一个线程进行上传或下载 . 什么是单点登录？如何实现？SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"Algorithm","slug":"Algorithm","date":"2024-07-30T07:30:00.000Z","updated":"2024-08-18T04:37:06.684Z","comments":true,"path":"2024/07/30/Algorithm/","permalink":"https://landaye.github.io/2024/07/30/Algorithm/","excerpt":"","text":"文章内容 9X9 数独 See the Pen Untitled by . (@LanDaye) on CodePen. 点击 这里 编辑和查看完整代码。 n 可以形成的真分数的数量使用欧拉函数实现 12345678910111213141516171819202122function properFractions(n) &#123; if (n &lt;= 1) &#123; return 0; // n 小于或等于 1 时，无法形成真分数 &#125; let re = n; // 初始化 re 为 n // 从 2 到 sqrt(n) 检查每个整数 i for (let i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; // 如果 i 是 n 的因子，则不断将 n 除以 i while (n % i == 0) &#123; n /= i; &#125; // 调整 re，排除包含因子 i 的分数 re -= re / i; &#125; &#125; // 如果 n 仍大于 1，说明 n 是一个质数 if (n &gt; 1) &#123; re -= re / n; &#125; return re; // 返回结果&#125; 整数转罗马数字1234567891011121314151617181920212223242526function toRoman(num) &#123; const romanToArabic = [ &#123; Roman: &quot;M&quot;, Arabic: 1000 &#125;, &#123; Roman: &quot;CM&quot;, Arabic: 900 &#125;, &#123; Roman: &quot;D&quot;, Arabic: 500 &#125;, &#123; Roman: &quot;CD&quot;, Arabic: 400 &#125;, &#123; Roman: &quot;C&quot;, Arabic: 100 &#125;, &#123; Roman: &quot;XC&quot;, Arabic: 90 &#125;, &#123; Roman: &quot;L&quot;, Arabic: 50 &#125;, &#123; Roman: &quot;XL&quot;, Arabic: 40 &#125;, &#123; Roman: &quot;X&quot;, Arabic: 10 &#125;, &#123; Roman: &quot;IX&quot;, Arabic: 9 &#125;, &#123; Roman: &quot;V&quot;, Arabic: 5 &#125;, &#123; Roman: &quot;IV&quot;, Arabic: 4 &#125;, &#123; Roman: &quot;I&quot;, Arabic: 1 &#125;, ]; let result = &quot;&quot;; romanToArabic.forEach((el) =&gt; &#123; //大到小取余数再比较 while (num &gt;= el.Arabic) &#123; result += el.Roman; num -= el.Arabic; &#125; &#125;); return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://landaye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"https://landaye.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"https://landaye.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}