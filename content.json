{"meta":{"title":"兰大爷","subtitle":"兰大爷'S BLOG","description":"悟已往之不谏,知来者之可追","author":"兰大爷","url":"https://landaye.github.io","root":"/"},"pages":[{"title":"关于","date":"2024-07-30T04:22:15.000Z","updated":"2024-08-03T08:03:55.986Z","comments":true,"path":"about/index.html","permalink":"https://landaye.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-07-30T01:06:49.559Z","updated":"2024-07-30T01:06:49.559Z","comments":true,"path":"categories/index.html","permalink":"https://landaye.github.io/categories/index.html","excerpt":"","text":""},{"title":"五湖四海皆是朋友!","date":"2024-07-31T03:44:03.828Z","updated":"2024-07-31T03:44:03.828Z","comments":true,"path":"friends/index.html","permalink":"https://landaye.github.io/friends/index.html","excerpt":"","text":"Contact Me"},{"title":"安居","date":"2024-08-03T14:13:16.842Z","updated":"2024-08-03T14:13:16.842Z","comments":true,"path":"projects/anju.html","permalink":"https://landaye.github.io/projects/anju.html","excerpt":"","text":""},{"title":"项目","date":"2024-07-31T11:09:31.199Z","updated":"2024-07-31T11:09:31.199Z","comments":true,"path":"projects/index.html","permalink":"https://landaye.github.io/projects/index.html","excerpt":"","text":""},{"title":"阿星商城","date":"2024-08-03T14:11:36.933Z","updated":"2024-08-03T14:11:36.933Z","comments":true,"path":"projects/axing.html","permalink":"https://landaye.github.io/projects/axing.html","excerpt":"","text":""},{"title":"search","date":"2024-07-30T04:14:19.000Z","updated":"2024-07-30T04:15:07.512Z","comments":true,"path":"search/index.html","permalink":"https://landaye.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue","slug":"Vue","date":"2024-07-31T07:30:00.000Z","updated":"2024-08-04T12:47:34.838Z","comments":true,"path":"2024/07/31/Vue/","permalink":"https://landaye.github.io/2024/07/31/Vue/","excerpt":"","text":"文章内容 渐进式 JavaScript 框架易学易用，性能出色，适用场景丰富的 Web 前端框架。 Vue 的两个核心功能： 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM . 说说你对 vue 的理解 渐进式框架 组件化 响应式系统 虚拟DOM 单文件组件 (SFC) Vue CLI Vue Router 和 Vuex . 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢？ 单页应用（Single Page Application, SPA）是一种Web应用程序，初次加载所需资源加载到浏览器中。通过JavaScript动态更新页面内容。通过发送网络请求和路由来实现数据获取和页面的导航。 优:用户体验好、快，内容的改变不需要重新加载整个页面。具有桌面应用的即时性、网站的可移植性和可访问性。良好的前后端分离，分工更明确。 缺:SEO不友好，不利于搜索引擎的抓取。首次渲染速度相对较慢。 实现SPA:HTML结构：定义页面的基本结构。路由功能：实现一个简单的路由系统，根据URL路径动态加载不同的内容。内容更新：根据当前路由加载相应的内容。事件监听：监听用户的导航行为（例如点击链接）并触发路由更新。 . 如何给SPA做SEO？ SSR服务端渲染将组件或页面通过服务器生成html，再返回给浏览器，如Vue.js–&gt;Nuxt.js React–&gt;Next.js 静态化（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）通过WEB服务器的 URL Rewrite的方式，把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。 使用Phantomjs针对爬虫处理 . 请描述下你对vue生命周期的理解？ beforeCreate 插件开发中执行一些初始化任务 created 用于异步数据获取 beforeMount 未执行渲染、更新，dom未创建 mounted 用于获取访问数据和dom元素 beforeUpdate 用于获取更新前各种状态 updated 更新后，所有状态已是最新 beforeDestroy 用于一些定时器或订阅的取消 destroyed 组件已销毁，作用同上 . 说说你对keep-alive的理解是什么？缓存后如何获取数据? 设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：首次：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated再次：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated 获取数据：beforeRouteEnteractived注意：服务器端渲染期间avtived不被调用 . 在created和mounted这两个生命周期中请求数据有什么区别呢？created是在组件实例一旦创建完成的时候立刻调用，页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。都能拿到实例对象的属性和方法。放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。 . v-if和v-for的优先级是什么？v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染同一标签进行if判断的时候，v-for是比v-if先进行判断，v-for优先级比v-if高 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断） . Vue组件之间的通信方式都有哪些？vue中8种常规的通信方案 通过 props 传递 父–&gt;子 通过 $emit 触发自定义事件 子–&gt;父子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值父组件绑定监听器获取到子组件传递过来的参数 使用 ref 子–&gt;父 通过获取dom元素传值 EventBus 兄–&gt;兄 $parent 或$root 兄–&gt;兄 通过共同祖辈$parent或者$root搭建通信桥连 attrs 与 listeners 祖–&gt;孙 Provide 与 Inject 祖–&gt;孙在祖先组件定义provide属性，返回传递的值在后代组件通过inject接收组件传递过来的值 Vuex –&gt;复杂关系的组件数据传递Vuex作用相当于一个用来存储共享变量的容器 . VueX state用来存放共享变量的地方 getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值 mutations用来存放修改state的方法。 actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作 . Vue中的$nextTick有什么作用？&#36;nextTick的主要作用是延迟执行某些代码，直到 Vue 完成更新 DOM。用于在数据变化引发的 DOM 更新完成后执行延迟回调。 . 你了解vue的diff算法吗？说说看？ diff 算法是一种通过同层的树节点进行比较的高效算法diff整体策略为：深度优先，同层比较 两个特点：比较只会在同层级进行, 不会跨层级比较在diff比较的过程中，循环从两边向中间比较 render 函数render 函数是 Vue 组件中的一个方法，用于描述组件的视图结构。它返回一个虚拟 DOM 节点树 (VNode)，Vue 根据这个虚拟 DOM 树来更新真实 DOM。 h 函数h 函数（也称为 createElement 函数）是用于创建虚拟 DOM 节点的工具。它是 render 函数的主要构建工具，用于生成虚拟 DOM 树。 patch 函数patch 函数是虚拟 DOM 操作的核心，用于比较新旧虚拟 DOM 树，并将变化应用到真实 DOM 上。它是 Vue 内部的一个重要机制，确保视图更新的高效性。 . Vue项目中有封装过axios吗？主要是封装哪方面的？ 设置接口请求前缀利用node环境变量来作判断，用来区分开发、测试、生产环境在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域 设置请求头与超时时间 封装请求方法先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去 请求拦截器请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便 响应拦截器响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权 . Vue项目中你是如何解决跨域的呢？ JSONP (JSON with Padding)JSONP 是一种通过 &lt;script&gt; 标签实现跨域请求的方法。它只能用于 GET 请求。 CORS (Cross-Origin Resource Sharing)CORS 是一种 W3C 标准，它允许服务器通过 HTTP 头来指示哪些来源站点可以访问该服务器的资源。服务器需要配置相应的响应头： 代理服务器通过设置代理服务器，可以让前端向同源的代理服务器发送请求，再由代理服务器向目标服务器发送请求，代理服务器接收到响应后再返回给前端。 Nginx 反向代理使用 Nginx 配置反向代理，将请求代理到目标服务器。 使用 HTML5 的 iframe 和 postMessage通过在父页面和子页面之间使用 iframe 和 postMessage 来实现跨域通信。","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"面试/Vue","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/Vue/"}],"tags":[]},{"title":"React","slug":"React","date":"2024-07-30T08:30:00.000Z","updated":"2024-08-04T12:47:40.811Z","comments":true,"path":"2024/07/30/React/","permalink":"https://landaye.github.io/2024/07/30/React/","excerpt":"","text":"文章内容","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"React","slug":"面试/React","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/React/"}],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2024-07-30T07:50:00.000Z","updated":"2024-08-04T12:47:20.357Z","comments":true,"path":"2024/07/30/JavaScript/","permalink":"https://landaye.github.io/2024/07/30/JavaScript/","excerpt":"","text":"文章内容 JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（built-in）对象和方法。 . 说说 JavaScript 中的数据类型？存储上的差别？在JavaScript中，我们可以分成两种类型： 基本类型 存储在栈中 String Boolean Undefined null symbol 复杂类型 存储于堆中 Object Array Function . 深拷贝浅拷贝的区别？如何实现一个深拷贝？ 浅拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址（只拷贝栈内存内的） Object.assignArray.prototype.slice(), Array.prototype.concat()使用拓展运算符实现的复制、 深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 _.cloneDeep()jQuery.extend()JSON.stringify()手写循环递归 . 说说你对闭包的理解？闭包使用场景？ 定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。优点是可以避免变量的污染缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 使用场景：创建私有变量延长变量的生命周期 . 柯里化函数柯里化是函数式编程中的重要概念，通过将多参数函数转换为一系列单参数函数，使得代码更灵活、更易复用。它可以用于函数复用、延迟计算和函数配置等场景。 123456789101112function getArea(width) &#123; return height =&gt; &#123; return width * height; &#125;&#125;const getTenWidthArea = getArea(10);// 之后碰到宽度为10的长方形就可以这样计算面积const area1 = getTenWidthArea(20); // 200// 而且如果遇到宽度偶尔变化也可以轻松复用const getTwentyWidthArea = getArea(20);const area2 = getTwentyWidthArea(15); // 300 . 说说你对作用域链的理解？ 全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问 函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问 块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量 . 变量提升变量提升是JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。let 和 const 声明的变量也会被提升，但在声明之前访问它们会导致 ReferenceError。函数提升：函数声明会被提升到作用域顶部，而函数表达式不会被提升。 . JavaScript原型，原型链 ? 有什么特点？ 原型每个对象都会在其内部初始化一个属性，就是prototype（原型）。proto 是每个对象（包括实例对象和函数对象）都有的一个属性，它指向该对象的原型。prototype 是函数对象（包括构造函数）的一个属性，它用于创建实例对象的原型。 原型链引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层，组成原型链。原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。 继承存在的意义就是属性共享：好处有二：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性 . Javascript如何实现继承？ 原型链继承 构造函数继承（借助 call） 组合继承 原型式继承 寄生式继承 寄生组合式继承 . JavaScript中执行上下文和执行栈是什么？执行上下文是一种对Javascript代码执行环境的抽象概念. 执行上下文的类型分为三种： 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用 执行栈 执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文 . 说说JavaScript中的事件模型 事件 是用户或浏览器执行的某种动作，可以通过事件监听器进行监听。 事件流 描述事件在页面元素之间的传播方式。事件流三个阶段： 事件捕获阶段(capture phase) 处于目标阶段(target phase) 事件冒泡阶段(bubbling phase) 事件委托 是将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。 事件对象 包含关于事件的详细信息，可在事件处理函数中使用。 事件模型 事件模型可以分为三种： 原始事件模型（DOM0级） 不支持事件捕获 123var btn = document.getElementById(&#x27;.btn&#x27;);btn.onclick = fun; 标准事件模型（DOM2级） 捕获、目标和冒泡 123var btn = document.getElementById(&#x27;.btn&#x27;);btn.addEventListener(‘click’, showMessage, false);btn.removeEventListener(‘click’, showMessage, false); IE事件模型（基本不用） 不支持事件捕获 123var btn = document.getElementById(&#x27;.btn&#x27;);btn.attachEvent(‘onclick’, showMessage);btn.detachEvent(‘onclick’, showMessage); . typeof 与 instanceof 区别 typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值 instanceof 可判断复杂引用数据类型，不能判断基础数据类型 而typeof 也存在弊端，可以判断基础数据类型（null 除外），引用数据类型中，除了function 类型，其他的也无法判断 如果需要通用检测数据类型，可以采用Object.prototype.toString(xxx)，调用该方法，统一返回格式“[object Xxx]”的字符串 . 解释下什么是事件代理(事件委托)？应用场景？ 将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。 . 说说new操作符具体干了什么？12345678910function mynew(Func, ...args) &#123; // 1.创建一个新对象 const obj = &#123;&#125; // 2.新对象原型指向构造函数原型对象 obj.__proto__ = Func.prototype // 3.将构建函数的this指向新对象 let result = Func.apply(obj, args) // 4.根据构造函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理 return result instanceof Object ? result : obj&#125; . bind、call、apply 区别？如何实现一个bind?call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向 三者都可以改变函数的this对象指向 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入 bind是返回绑定this之后的函数，apply、call 则是立即执行 . 说说你对事件循环的理解 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前常见的微任务有：Promise.thenMutaionObserverObject.observe（已废弃；Proxy 对象替代）process.nextTick（Node.js） 宏任务常见的宏任务有：script (可以理解为外层同步代码)setTimeout&#x2F;setIntervalUI rendering&#x2F;UI事件postMessage、MessageChannelsetImmediate、I&#x2F;O（Node.js） 事件循环的执行顺序 执行全局代码（整体代码作为一个宏任务执行）。 遇到异步任务时，将其放入对应的任务队列。 当前宏任务执行完成后，检查并执行所有微任务队列中的任务，直到微任务队列为空。 执行下一个宏任务（从宏任务队列中取出一个任务并执行）。 重复上述过程。 12345678910111213141516171819console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log(&#x27;new Promise&#x27;) resolve()&#125;).then(()=&gt;&#123; console.log(&#x27;then&#x27;)&#125;)console.log(3)// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 . 说说你对BOM的理解，常见的BOM对象你了解哪些？BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象其作用就是跟浏览器做一些交互效果. window 对象 location 对象 history 对象 navigator 对象 screen 对象 Document 对象 . 举例说明你对尾递归的理解，有哪些应用场景123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 数组求和 求斐波那契数列 数组扁平化 数组扁平化是将多维数组转换为一维数组的过程. Array.prototype.flat() Array.prototype.reduce() 数组对象格式化 . Javascript本地存储的方式有哪些？区别及应用场景？ 标记用户与跟踪用户行为的情况，推荐使用cookie 适合长期保存在本地的数据（令牌），推荐使用localStorage 敏感账号一次性登录，推荐使用sessionStorage 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB . 说说你对函数式编程的理解？优缺点？函数式编程是一种”编程范式”（programming paradigm）主要的编程范式有三种：命令式编程，声明式编程和函数式编程. 函数式编程更加强调程序执行的结果而非执行的过程. 1234567// 命令式编程var array = [0, 1, 2, 3]for(let i = 0; i &lt; array.length; i++) &#123; array[i] = Math.pow(array[i], 2)&#125;// 函数式方式[0, 1, 2, 3].map(num =&gt; Math.pow(num, 2)) . Javascript中如何实现函数缓存？函数缓存有哪些应用场景？ 闭包 柯里化 高阶函数 用于计算耗时、可能重复利用多次，且是纯函数的纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用 . 什么是防抖和节流？有什么区别？如何实现？ 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 1234567891011function throttled2(fn, delay = 500) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) timer = null &#125;, delay); &#125; &#125;&#125; 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 12345678910111213function debounce(func, wait) &#123; let timeout; return function () &#123; let context = this; // 保存this指向 let args = arguments; // 拿到event对象 clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125;","categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"面试/JavaScript","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/JavaScript/"}],"tags":[]},{"title":"Algorithm","slug":"Algorithm","date":"2024-07-30T07:30:00.000Z","updated":"2024-08-04T12:46:49.355Z","comments":true,"path":"2024/07/30/Algorithm/","permalink":"https://landaye.github.io/2024/07/30/Algorithm/","excerpt":"","text":"文章内容 9X9数独 See the Pen Untitled by . (@LanDaye) on CodePen. 点击 这里 编辑和查看完整代码。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://landaye.github.io/categories/Algorithm/"}],"tags":[]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"面试/Vue","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/Vue/"},{"name":"React","slug":"面试/React","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/React/"},{"name":"JavaScript","slug":"面试/JavaScript","permalink":"https://landaye.github.io/categories/%E9%9D%A2%E8%AF%95/JavaScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://landaye.github.io/categories/Algorithm/"}],"tags":[]}