[{"title":"React","url":"https://landaye.github.io/2024/07/30/React/","content":"<h1 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h1><hr>\n","categories":["面试","React"],"tags":[]},{"title":"Vue","url":"https://landaye.github.io/2024/07/30/Vue/","content":"<h1 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h1><hr>\n<p>渐进式 JavaScript 框架易学易用，性能出色，适用场景丰富的 Web 前端框架。</p>\n<p> Vue 的两个核心功能：</p>\n<ul>\n<li><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</li>\n<li><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM</li>\n</ul>\n<h2 id=\"说说你对-vue-的理解\"><a href=\"#说说你对-vue-的理解\" class=\"headerlink\" title=\". 说说你对 vue 的理解\"></a>. 说说你对 vue 的理解</h2><ol>\n<li>渐进式框架</li>\n<li>组件化</li>\n<li>响应式系统</li>\n<li>虚拟DOM</li>\n<li>单文件组件 (SFC)</li>\n<li>Vue CLI</li>\n<li>Vue Router 和 Vuex</li>\n</ol>\n<h2 id=\"你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢？\"><a href=\"#你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢？\" class=\"headerlink\" title=\". 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢？\"></a>. 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢？</h2><ol>\n<li>单页应用（Single Page Application, SPA）是一种Web应用程序，初次加载所需资源加载到浏览器中。通过JavaScript动态更新页面内容。通过发送网络请求和路由来实现数据获取和页面的导航。</li>\n<li>优:<br>用户体验好、快，内容的改变不需要重新加载整个页面。<br>具有桌面应用的即时性、网站的可移植性和可访问性。<br>良好的前后端分离，分工更明确。</li>\n<li>缺:<br>SEO不友好，不利于搜索引擎的抓取。<br>首次渲染速度相对较慢。</li>\n<li>实现SPA:<br>HTML结构：定义页面的基本结构。<br>路由功能：实现一个简单的路由系统，根据URL路径动态加载不同的内容。<br>内容更新：根据当前路由加载相应的内容。<br>事件监听：监听用户的导航行为（例如点击链接）并触发路由更新。</li>\n</ol>\n<h2 id=\"如何给SPA做SEO？\"><a href=\"#如何给SPA做SEO？\" class=\"headerlink\" title=\". 如何给SPA做SEO？\"></a>. 如何给SPA做SEO？</h2><ol>\n<li>SSR服务端渲染<br>将组件或页面通过服务器生成html，再返回给浏览器，如Vue.js–&gt;Nuxt.js  React–&gt;Next.js</li>\n<li>静态化<br>（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中<br>（2）通过WEB服务器的 URL Rewrite的方式，把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。</li>\n<li>使用Phantomjs针对爬虫处理</li>\n</ol>\n<h2 id=\"请描述下你对vue生命周期的理解？\"><a href=\"#请描述下你对vue生命周期的理解？\" class=\"headerlink\" title=\". 请描述下你对vue生命周期的理解？\"></a>. 请描述下你对vue生命周期的理解？</h2><p><img src=\"/../images/vue%5C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"Cover Image Description\"></p>\n<ol>\n<li>beforeCreate     插件开发中执行一些初始化任务</li>\n<li>created\t        用于异步数据获取</li>\n<li>beforeMount\t    未执行渲染、更新，dom未创建</li>\n<li>mounted\t        用于获取访问数据和dom元素</li>\n<li>beforeUpdate     用于获取更新前各种状态</li>\n<li>updated\t        更新后，所有状态已是最新</li>\n<li>beforeDestroy\t  用于一些定时器或订阅的取消</li>\n<li>destroyed\t      组件已销毁，作用同上</li>\n</ol>\n<h2 id=\"说说你对keep-alive的理解是什么？缓存后如何获取数据\"><a href=\"#说说你对keep-alive的理解是什么？缓存后如何获取数据\" class=\"headerlink\" title=\". 说说你对keep-alive的理解是什么？缓存后如何获取数据?\"></a>. 说说你对keep-alive的理解是什么？缓存后如何获取数据?</h2><ol>\n<li><p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：<br>首次：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated<br>再次：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated</p>\n</li>\n<li><p>获取数据：<br>beforeRouteEnter<br>actived<br>注意：服务器端渲染期间avtived不被调用</p>\n</li>\n</ol>\n<h2 id=\"在created和mounted这两个生命周期中请求数据有什么区别呢？\"><a href=\"#在created和mounted这两个生命周期中请求数据有什么区别呢？\" class=\"headerlink\" title=\". 在created和mounted这两个生命周期中请求数据有什么区别呢？\"></a>. 在created和mounted这两个生命周期中请求数据有什么区别呢？</h2><p>created是在组件实例一旦创建完成的时候立刻调用，页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。都能拿到实例对象的属性和方法。放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。</p>\n<h2 id=\"v-if和v-for的优先级是什么？\"><a href=\"#v-if和v-for的优先级是什么？\" class=\"headerlink\" title=\". v-if和v-for的优先级是什么？\"></a>. v-if和v-for的优先级是什么？</h2><p>v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染<br>同一标签进行if判断的时候，v-for是比v-if先进行判断，v-for优先级比v-if高</p>\n<p>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p>\n<h2 id=\"Vue组件之间的通信方式都有哪些？\"><a href=\"#Vue组件之间的通信方式都有哪些？\" class=\"headerlink\" title=\". Vue组件之间的通信方式都有哪些？\"></a>. Vue组件之间的通信方式都有哪些？</h2><p>vue中8种常规的通信方案</p>\n<ol>\n<li>通过 props 传递  父–&gt;子</li>\n<li>通过 $emit 触发自定义事件   子–&gt;父<br>子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值<br>父组件绑定监听器获取到子组件传递过来的参数</li>\n<li>使用 ref   子–&gt;父   通过获取dom元素传值</li>\n<li>EventBus   兄–&gt;兄</li>\n<li>$parent 或$root   兄–&gt;兄     通过共同祖辈$parent或者$root搭建通信桥连</li>\n<li>attrs 与 listeners   祖–&gt;孙  </li>\n<li>Provide 与 Inject    祖–&gt;孙<br>在祖先组件定义provide属性，返回传递的值<br>在后代组件通过inject接收组件传递过来的值</li>\n<li>Vuex  –&gt;复杂关系的组件数据传递<br>Vuex作用相当于一个用来存储共享变量的容器</li>\n</ol>\n<h2 id=\"VueX\"><a href=\"#VueX\" class=\"headerlink\" title=\".  VueX\"></a>.  VueX</h2><ol>\n<li>state用来存放共享变量的地方</li>\n<li>getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值</li>\n<li>mutations用来存放修改state的方法。</li>\n<li>actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作</li>\n</ol>\n<h2 id=\"Vue中的-nextTick有什么作用？\"><a href=\"#Vue中的-nextTick有什么作用？\" class=\"headerlink\" title=\".  Vue中的$nextTick有什么作用？\"></a>.  Vue中的$nextTick有什么作用？</h2><p>&#36;nextTick的主要作用是延迟执行某些代码，直到 Vue 完成更新 DOM。用于在数据变化引发的 DOM 更新完成后执行延迟回调。</p>\n<h2 id=\"你了解vue的diff算法吗？说说看？\"><a href=\"#你了解vue的diff算法吗？说说看？\" class=\"headerlink\" title=\".  你了解vue的diff算法吗？说说看？\"></a>.  你了解vue的diff算法吗？说说看？</h2><ol>\n<li><p>diff 算法是一种通过同层的树节点进行比较的高效算法<br>diff整体策略为：深度优先，同层比较</p>\n</li>\n<li><p>两个特点：<br>比较只会在同层级进行, 不会跨层级比较<br>在diff比较的过程中，循环从两边向中间比较</p>\n</li>\n<li><p>render 函数<br>render 函数是 Vue 组件中的一个方法，用于描述组件的视图结构。它返回一个虚拟 DOM 节点树 (VNode)，Vue 根据这个虚拟 DOM 树来更新真实 DOM。</p>\n</li>\n<li><p>h 函数<br>h 函数（也称为 createElement 函数）是用于创建虚拟 DOM 节点的工具。它是 render 函数的主要构建工具，用于生成虚拟 DOM 树。</p>\n</li>\n<li><p>patch 函数<br>patch 函数是虚拟 DOM 操作的核心，用于比较新旧虚拟 DOM 树，并将变化应用到真实 DOM 上。它是 Vue 内部的一个重要机制，确保视图更新的高效性。</p>\n</li>\n</ol>\n<h2 id=\"Vue项目中有封装过axios吗？主要是封装哪方面的？\"><a href=\"#Vue项目中有封装过axios吗？主要是封装哪方面的？\" class=\"headerlink\" title=\".  Vue项目中有封装过axios吗？主要是封装哪方面的？\"></a>.  Vue项目中有封装过axios吗？主要是封装哪方面的？</h2><ol>\n<li>设置接口请求前缀<br>利用node环境变量来作判断，用来区分开发、测试、生产环境<br>在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域</li>\n<li>设置请求头与超时时间</li>\n<li>封装请求方法<br>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</li>\n<li>请求拦截器<br>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</li>\n<li>响应拦截器<br>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</li>\n</ol>\n<h2 id=\"Vue项目中你是如何解决跨域的呢？\"><a href=\"#Vue项目中你是如何解决跨域的呢？\" class=\"headerlink\" title=\". Vue项目中你是如何解决跨域的呢？\"></a>. Vue项目中你是如何解决跨域的呢？</h2><ol>\n<li>JSONP (JSON with Padding)<br>JSONP 是一种通过 &lt;script&gt; 标签实现跨域请求的方法。它只能用于 GET 请求。</li>\n<li>CORS (Cross-Origin Resource Sharing)<br>CORS 是一种 W3C 标准，它允许服务器通过 HTTP 头来指示哪些来源站点可以访问该服务器的资源。服务器需要配置相应的响应头：</li>\n<li>代理服务器<br>通过设置代理服务器，可以让前端向同源的代理服务器发送请求，再由代理服务器向目标服务器发送请求，代理服务器接收到响应后再返回给前端。</li>\n<li>Nginx 反向代理<br>使用 Nginx 配置反向代理，将请求代理到目标服务器。</li>\n<li>使用 HTML5 的 iframe 和 postMessage<br>通过在父页面和子页面之间使用 iframe 和 postMessage 来实现跨域通信。</li>\n</ol>\n","categories":["面试","Vue"],"tags":[]},{"title":"Algorithm","url":"https://landaye.github.io/2023/07/30/Algorithm/","content":"<h1 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h1><hr>\n<h2 id=\"9X9数独\"><a href=\"#9X9数独\" class=\"headerlink\" title=\"9X9数独\"></a>9X9数独</h2><div class=\"iframe\">\n  <iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Untitled\" src=\"https://codepen.io/LanDaye/embed/eYwgxKQ?default-tab=js%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/LanDaye/pen/eYwgxKQ\">\n  Untitled</a> by . (<a href=\"https://codepen.io/LanDaye\">@LanDaye</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n  <p>点击 <a href=\"https://codepen.io/LanDaye/pen/eYwgxKQ\" target=\"_blank\">这里</a> 编辑和查看完整代码。</p>\n</div>\n","categories":["Algorithm"],"tags":[]},{"title":"JavaScript","url":"https://landaye.github.io/2023/07/30/JavaScript/","content":"<h1 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h1><hr>\n<p>JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（built-in）对象和方法。</p>\n<h2 id=\"说说-JavaScript-中的数据类型？存储上的差别？\"><a href=\"#说说-JavaScript-中的数据类型？存储上的差别？\" class=\"headerlink\" title=\". 说说 JavaScript 中的数据类型？存储上的差别？\"></a>. 说说 JavaScript 中的数据类型？存储上的差别？</h2><p>在<code>JavaScript</code>中，我们可以分成两种类型：</p>\n<ol>\n<li>基本类型 存储在栈中<ol>\n<li>String</li>\n<li>Boolean</li>\n<li>Undefined</li>\n<li>null</li>\n<li>symbol</li>\n</ol>\n</li>\n<li>复杂类型 存储于堆中<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Function</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"深拷贝浅拷贝的区别？如何实现一个深拷贝？\"><a href=\"#深拷贝浅拷贝的区别？如何实现一个深拷贝？\" class=\"headerlink\" title=\". 深拷贝浅拷贝的区别？如何实现一个深拷贝？\"></a>. 深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2><ol>\n<li>浅拷贝</li>\n</ol>\n<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址（只拷贝栈内存内的）</p>\n<p>Object.assign<br>Array.prototype.slice(), Array.prototype.concat()<br>使用拓展运算符实现的复制、</p>\n<ol>\n<li>深拷贝<br>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</li>\n</ol>\n<p>_.cloneDeep()<br>jQuery.extend()<br>JSON.stringify()<br>手写循环递归</p>\n<h2 id=\"说说你对闭包的理解？闭包使用场景？\"><a href=\"#说说你对闭包的理解？闭包使用场景？\" class=\"headerlink\" title=\". 说说你对闭包的理解？闭包使用场景？\"></a>. 说说你对闭包的理解？闭包使用场景？</h2><ol>\n<li><p>定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。<br>优点是可以避免变量的污染<br>缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>\n</li>\n<li><p>使用场景：<br>创建私有变量<br>延长变量的生命周期</p>\n</li>\n</ol>\n<h2 id=\"柯里化函数\"><a href=\"#柯里化函数\" class=\"headerlink\" title=\". 柯里化函数\"></a>. 柯里化函数</h2><p>柯里化是函数式编程中的重要概念，通过将多参数函数转换为一系列单参数函数，使得代码更灵活、更易复用。它可以用于函数复用、延迟计算和函数配置等场景。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getArea</span>(<span class=\"params\">width</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">height</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> width * height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getTenWidthArea = <span class=\"title function_\">getArea</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 之后碰到宽度为10的长方形就可以这样计算面积</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> area1 = <span class=\"title function_\">getTenWidthArea</span>(<span class=\"number\">20</span>); <span class=\"comment\">// 200</span></span><br><span class=\"line\"><span class=\"comment\">// 而且如果遇到宽度偶尔变化也可以轻松复用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getTwentyWidthArea = <span class=\"title function_\">getArea</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> area2 = <span class=\"title function_\">getTwentyWidthArea</span>(<span class=\"number\">15</span>); <span class=\"comment\">// 300</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"说说你对作用域链的理解？\"><a href=\"#说说你对作用域链的理解？\" class=\"headerlink\" title=\". 说说你对作用域链的理解？\"></a>. 说说你对作用域链的理解？</h2><ol>\n<li><p>全局作用域<br>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p>\n</li>\n<li><p>函数作用域<br>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p>\n</li>\n<li><p>块级作用域<br>ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p>\n</li>\n</ol>\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\". 变量提升\"></a>. 变量提升</h2><p>变量提升是JavaScript引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。<br>let 和 const 声明的变量也会被提升，但在声明之前访问它们会导致 ReferenceError。<br>函数提升：函数声明会被提升到作用域顶部，而函数表达式不会被提升。</p>\n<h2 id=\"JavaScript原型，原型链-有什么特点？\"><a href=\"#JavaScript原型，原型链-有什么特点？\" class=\"headerlink\" title=\". JavaScript原型，原型链 ? 有什么特点？\"></a>. JavaScript原型，原型链 ? 有什么特点？</h2><ol>\n<li><p>原型<br>每个对象都会在其内部初始化一个属性，就是prototype（原型）。<br><strong>proto</strong> 是每个对象（包括实例对象和函数对象）都有的一个属性，它指向该对象的原型。<br>prototype 是函数对象（包括构造函数）的一个属性，它用于创建实例对象的原型。</p>\n</li>\n<li><p>原型链<br>引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层，组成原型链。原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。</p>\n</li>\n<li><p>继承存在的意义就是属性共享：好处有二：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性</p>\n</li>\n</ol>\n<h2 id=\"Javascript如何实现继承？\"><a href=\"#Javascript如何实现继承？\" class=\"headerlink\" title=\". Javascript如何实现继承？\"></a>. Javascript如何实现继承？</h2><ol>\n<li>原型链继承</li>\n<li>构造函数继承（借助 call）</li>\n<li>组合继承</li>\n<li>原型式继承</li>\n<li>寄生式继承</li>\n<li>寄生组合式继承</li>\n</ol>\n<h2 id=\"JavaScript中执行上下文和执行栈是什么？\"><a href=\"#JavaScript中执行上下文和执行栈是什么？\" class=\"headerlink\" title=\". JavaScript中执行上下文和执行栈是什么？\"></a>. JavaScript中执行上下文和执行栈是什么？</h2><p>执行上下文是一种对Javascript代码执行环境的抽象概念. </p>\n<p>执行上下文的类型分为三种：</p>\n<ol>\n<li>全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象</li>\n<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</li>\n<li>Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用</li>\n</ol>\n<p>执行栈</p>\n<p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文</p>\n<h2 id=\"说说JavaScript中的事件模型\"><a href=\"#说说JavaScript中的事件模型\" class=\"headerlink\" title=\". 说说JavaScript中的事件模型\"></a>. 说说JavaScript中的事件模型</h2><ol>\n<li>事件 是用户或浏览器执行的某种动作，可以通过事件监听器进行监听。</li>\n<li>事件流 描述事件在页面元素之间的传播方式。<br>事件流三个阶段：<br>  事件捕获阶段(capture phase)<br>  处于目标阶段(target phase)<br>  事件冒泡阶段(bubbling phase)</li>\n<li>事件委托 是将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。</li>\n<li>事件对象 包含关于事件的详细信息，可在事件处理函数中使用。</li>\n</ol>\n<p>事件模型</p>\n<p>事件模型可以分为三种：</p>\n<p>原始事件模型（DOM0级） 不支持事件捕获</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;.btn&#x27;</span>);</span><br><span class=\"line\">btn.<span class=\"property\">onclick</span> = fun;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>标准事件模型（DOM2级） 捕获、目标和冒泡</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;.btn&#x27;</span>);</span><br><span class=\"line\">btn.<span class=\"title function_\">addEventListener</span>(‘click’, showMessage, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.<span class=\"title function_\">removeEventListener</span>(‘click’, showMessage, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>IE事件模型（基本不用） 不支持事件捕获</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;.btn&#x27;</span>);</span><br><span class=\"line\">btn.<span class=\"title function_\">attachEvent</span>(‘onclick’, showMessage);</span><br><span class=\"line\">btn.<span class=\"title function_\">detachEvent</span>(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure>\n<h2 id=\"typeof-与-instanceof-区别\"><a href=\"#typeof-与-instanceof-区别\" class=\"headerlink\" title=\". typeof 与 instanceof 区别\"></a>. typeof 与 instanceof 区别</h2><ol>\n<li>typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</li>\n<li>instanceof 可判断复杂引用数据类型，不能判断基础数据类型</li>\n<li>而typeof 也存在弊端，可以判断基础数据类型（null 除外），引用数据类型中，除了function 类型，其他的也无法判断</li>\n</ol>\n<p>如果需要通用检测数据类型，可以采用Object.prototype.toString(xxx)，调用该方法，统一返回格式“[object Xxx]”的字符串</p>\n<h2 id=\"解释下什么是事件代理-事件委托-？应用场景？\"><a href=\"#解释下什么是事件代理-事件委托-？应用场景？\" class=\"headerlink\" title=\". 解释下什么是事件代理(事件委托)？应用场景？\"></a>. 解释下什么是事件代理(事件委托)？应用场景？</h2><p>  将事件监听器添加到父级元素，通过事件冒泡处理子元素事件的技术。</p>\n<h2 id=\"说说new操作符具体干了什么？\"><a href=\"#说说new操作符具体干了什么？\" class=\"headerlink\" title=\". 说说new操作符具体干了什么？\"></a>. 说说new操作符具体干了什么？</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">mynew</span>(<span class=\"params\">Func, ...args</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.创建一个新对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.新对象原型指向构造函数原型对象</span></span><br><span class=\"line\">    obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Func</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\">    <span class=\"comment\">// 3.将构建函数的this指向新对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"title class_\">Func</span>.<span class=\"title function_\">apply</span>(obj, args)</span><br><span class=\"line\">    <span class=\"comment\">// 4.根据构造函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind、call、apply-区别？如何实现一个bind\"><a href=\"#bind、call、apply-区别？如何实现一个bind\" class=\"headerlink\" title=\". bind、call、apply 区别？如何实现一个bind?\"></a>. bind、call、apply 区别？如何实现一个bind?</h2><p>call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</p>\n<ol>\n<li>三者都可以改变函数的this对象指向</li>\n<li>三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window</li>\n<li>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入</li>\n<li>bind是返回绑定this之后的函数，apply、call 则是立即执行</li>\n</ol>\n<h2 id=\"说说你对事件循环的理解\"><a href=\"#说说你对事件循环的理解\" class=\"headerlink\" title=\". 说说你对事件循环的理解\"></a>. 说说你对事件循环的理解</h2><ol>\n<li><p>微任务<br>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前<br>常见的微任务有：<br>Promise.then<br>MutaionObserver<br>Object.observe（已废弃；Proxy 对象替代）<br>process.nextTick（Node.js）</p>\n</li>\n<li><p>宏任务<br>常见的宏任务有：<br>script (可以理解为外层同步代码)<br>setTimeout&#x2F;setInterval<br>UI rendering&#x2F;UI事件<br>postMessage、MessageChannel<br>setImmediate、I&#x2F;O（Node.js）</p>\n</li>\n<li><p>事件循环的执行顺序</p>\n<ol>\n<li>执行全局代码（整体代码作为一个宏任务执行）。</li>\n<li>遇到异步任务时，将其放入对应的任务队列。</li>\n<li>当前宏任务执行完成后，检查并执行所有微任务队列中的任务，直到微任务队列为空。</li>\n<li>执行下一个宏任务（从宏任务队列中取出一个任务并执行）。</li>\n<li>重复上述过程。</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;new Promise&#x27;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;then&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遇到 console.log(1) ，直接打印 1</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到定时器，属于新的宏任务，留着后面执行</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// .then 属于微任务，放入微任务队列，后面再执行</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到 console.log(3) 直接打印 3</span></span><br><span class=\"line\"><span class=\"comment\">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"说说你对BOM的理解，常见的BOM对象你了解哪些？\"><a href=\"#说说你对BOM的理解，常见的BOM对象你了解哪些？\" class=\"headerlink\" title=\". 说说你对BOM的理解，常见的BOM对象你了解哪些？\"></a>. 说说你对BOM的理解，常见的BOM对象你了解哪些？</h2><p>BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象<br>其作用就是跟浏览器做一些交互效果.</p>\n<ol>\n<li>window 对象</li>\n<li>location 对象</li>\n<li>history 对象</li>\n<li>navigator 对象</li>\n<li>screen 对象</li>\n<li>Document 对象</li>\n</ol>\n<h2 id=\"举例说明你对尾递归的理解，有哪些应用场景\"><a href=\"#举例说明你对尾递归的理解，有哪些应用场景\" class=\"headerlink\" title=\". 举例说明你对尾递归的理解，有哪些应用场景\"></a>. 举例说明你对尾递归的理解，有哪些应用场景</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">factorial</span>(<span class=\"params\">n, total</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">factorial</span>(n - <span class=\"number\">1</span>, n * total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">factorial</span>(<span class=\"number\">5</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 120</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>数组求和</li>\n<li>求斐波那契数列</li>\n<li>数组扁平化  数组扁平化是将多维数组转换为一维数组的过程.<ol>\n<li>Array.prototype.flat()</li>\n<li>Array.prototype.reduce()</li>\n</ol>\n</li>\n<li>数组对象格式化</li>\n</ol>\n<h2 id=\"Javascript本地存储的方式有哪些？区别及应用场景？\"><a href=\"#Javascript本地存储的方式有哪些？区别及应用场景？\" class=\"headerlink\" title=\". Javascript本地存储的方式有哪些？区别及应用场景？\"></a>. Javascript本地存储的方式有哪些？区别及应用场景？</h2><ol>\n<li>标记用户与跟踪用户行为的情况，推荐使用cookie</li>\n<li>适合长期保存在本地的数据（令牌），推荐使用localStorage</li>\n<li>敏感账号一次性登录，推荐使用sessionStorage</li>\n<li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</li>\n</ol>\n<h2 id=\"说说你对函数式编程的理解？优缺点？\"><a href=\"#说说你对函数式编程的理解？优缺点？\" class=\"headerlink\" title=\". 说说你对函数式编程的理解？优缺点？\"></a>. 说说你对函数式编程的理解？优缺点？</h2><p>函数式编程是一种”编程范式”（programming paradigm）<br>主要的编程范式有三种：命令式编程，声明式编程和函数式编程.</p>\n<p>函数式编程更加强调程序执行的结果而非执行的过程.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式编程</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; array.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    array[i] = <span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(array[i], <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 函数式方式</span></span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(num, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Javascript中如何实现函数缓存？函数缓存有哪些应用场景？\"><a href=\"#Javascript中如何实现函数缓存？函数缓存有哪些应用场景？\" class=\"headerlink\" title=\". Javascript中如何实现函数缓存？函数缓存有哪些应用场景？\"></a>. Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</h2><ol>\n<li>闭包</li>\n<li>柯里化</li>\n<li>高阶函数<br>   用于计算耗时、可能重复利用多次，且是纯函数的<br>纯函数：<br>对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用</li>\n</ol>\n<h2 id=\"什么是防抖和节流？有什么区别？如何实现？\"><a href=\"#什么是防抖和节流？有什么区别？如何实现？\" class=\"headerlink\" title=\". 什么是防抖和节流？有什么区别？如何实现？\"></a>. 什么是防抖和节流？有什么区别？如何实现？</h2><ol>\n<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttled2</span>(<span class=\"params\">fn, delay = <span class=\"number\">500</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span></span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">func, wait</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>; <span class=\"comment\">// 保存this指向</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> args = <span class=\"variable language_\">arguments</span>; <span class=\"comment\">// 拿到event对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeout)</span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            func.<span class=\"title function_\">apply</span>(context, args)</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["面试","JavaScript"],"tags":[]},{"title":"五湖四海皆是朋友!","url":"https://landaye.github.io/friends/index.html","content":"<p><a href=\"mailto:a2219816262@163.com\" class=\"email-link\">Contact Me</a></p>\n","categories":[],"tags":[]},{"title":"categories","url":"https://landaye.github.io/categories/index.html","content":"","categories":[],"tags":[]},{"title":"安居","url":"https://landaye.github.io/projects/anju.html","content":"","categories":[],"tags":[]},{"title":"阿星商城","url":"https://landaye.github.io/projects/axing.html","content":"","categories":[],"tags":[]},{"title":"项目","url":"https://landaye.github.io/projects/index.html","content":"","categories":[],"tags":[]},{"title":"关于","url":"https://landaye.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://landaye.github.io/search/index.html","content":"","categories":[],"tags":[]}]